<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mcmc: lot.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>lot.cpp</h1><a href="lot_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">///</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">/// \file   lot.cpp</span>
<a name="l00003"></a>00003 <span class="comment"></span><span class="comment">/// \brief  Random number generators</span>
<a name="l00004"></a>00004 <span class="comment"></span><span class="comment">///</span>
<a name="l00005"></a>00005 <span class="comment"></span><span class="comment">/// A series of random number generators are provided here. Any one of three</span>
<a name="l00006"></a>00006 <span class="comment"></span><span class="comment">/// uniform random number generators can be chosen. By default the Mersenne</span>
<a name="l00007"></a>00007 <span class="comment"></span><span class="comment">/// twister is used.</span>
<a name="l00008"></a>00008 <span class="comment"></span><span class="comment">///</span>
<a name="l00009"></a>00009 <span class="comment"></span><span class="comment">/// \author Kent Holsinger &amp; Paul Lewis</span>
<a name="l00010"></a>00010 <span class="comment"></span><span class="comment">/// \date   2005-05-18</span>
<a name="l00011"></a>00011 <span class="comment"></span><span class="comment">///</span>
<a name="l00012"></a>00012 <span class="comment"></span><span class="comment">/// The random number generators from R have been checked for numerical </span>
<a name="l00013"></a>00013 <span class="comment"></span><span class="comment">/// accuracy with the routines in R v2.0. See lotTest.cpp for the specific</span>
<a name="l00014"></a>00014 <span class="comment"></span><span class="comment">/// small set of test run. In every case the results differ from those</span>
<a name="l00015"></a>00015 <span class="comment"></span><span class="comment">/// reported by R by less than 1.0e-11, and are exact for integer random</span>
<a name="l00016"></a>00016 <span class="comment"></span><span class="comment">/// variables.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">// This file is part of MCMC++, a library for constructing C++ programs</span>
<a name="l00019"></a>00019 <span class="comment">// that implement MCMC analyses of Bayesian statistical models.</span>
<a name="l00020"></a>00020 <span class="comment">// Copyright (c) 2004-2006 Kent E. Holsinger</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// MCMC++ is free software; you can redistribute it and/or modify</span>
<a name="l00023"></a>00023 <span class="comment">// it under the terms of the GNU General Public License as published by</span>
<a name="l00024"></a>00024 <span class="comment">// the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00025"></a>00025 <span class="comment">// (at your option) any later version.</span>
<a name="l00026"></a>00026 <span class="comment">//</span>
<a name="l00027"></a>00027 <span class="comment">// MCMC++ is distributed in the hope that it will be useful,</span>
<a name="l00028"></a>00028 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00029"></a>00029 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00030"></a>00030 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00033"></a>00033 <span class="comment">// along with MCMC++; if not, write to the Free Software</span>
<a name="l00034"></a>00034 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">// standard includes</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;cfloat&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;ctime&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00041"></a>00041 <span class="comment">// boost includes</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>
<a name="l00043"></a>00043 <span class="comment">// local includes</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include "<a class="code" href="lot_8h.html">mcmc++/lot.h</a>"</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">using</span> std::cerr;
<a name="l00047"></a>00047 <span class="keyword">using</span> std::endl;
<a name="l00048"></a>00048 <span class="keyword">using</span> std::vector;
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="namespacelot__conditions.html">00050</a> <span class="keyword">namespace </span>lot_conditions {
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   BOOST_STATIC_ASSERT(<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>) * CHAR_BIT == 32); <span class="comment">// 32 bit longs required</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 }
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">// defines necessary (or convenient) for functions imported from R</span><span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">/// Macro for compatibility with RNGs from R</span>
<a name="l00058"></a>00058 <span class="comment">///</span>
<a name="l00059"></a><a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">00059</a> <span class="comment"></span><span class="preprocessor">#define unif_rand() uniform()</span><span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">/// Macro for compatibility with RNGs from R</span>
<a name="l00061"></a>00061 <span class="comment">///</span>
<a name="l00062"></a><a class="code" href="lot_8cpp.html#1157a8d237f8bb89b614435b4ee1cbef">00062</a> <span class="comment"></span>#define exp_rand() expon()<span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment">/// Macro for compatibility with RNGs from R</span>
<a name="l00064"></a>00064 <span class="comment">///</span>
<a name="l00065"></a><a class="code" href="lot_8cpp.html#40a3b93beb4e8ce7a943839de82bb661">00065</a> <span class="comment"></span>#define norm_rand() snorm()<span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">/// Macro for compatibility with RNGs from R</span>
<a name="l00067"></a>00067 <span class="comment">///</span>
<a name="l00068"></a><a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">00068</a> <span class="comment"></span>#define repeat for (;;)
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keyword">namespace </span>{
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="comment">// for Mersenne twister</span>
<a name="l00073"></a>00073   <span class="comment">// Period parameters</span>
<a name="l00074"></a>00074   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> MATRIX_A = 0x9908b0dfUL;   <span class="comment">/* constant vector a */</span>
<a name="l00075"></a>00075   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> UPPER_MASK = 0x80000000UL; <span class="comment">/* most significant w-r bits */</span>
<a name="l00076"></a>00076   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> LOWER_MASK = 0x7fffffffUL; <span class="comment">/* least significant r bits */</span>
<a name="l00077"></a>00077   <span class="comment">// Tempering parameters</span>
<a name="l00078"></a>00078   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TEMPERING_MASK_B = 0x9d2c5680;
<a name="l00079"></a>00079   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TEMPERING_MASK_C = 0xefc60000;
<a name="l00080"></a>00080   <span class="keyword">inline</span> <span class="keywordtype">long</span> TEMPERING_SHIFT_U(<span class="keyword">const</span> <span class="keywordtype">long</span> y) {
<a name="l00081"></a>00081     <span class="keywordflow">return</span> (y &gt;&gt; 11);
<a name="l00082"></a>00082   }
<a name="l00083"></a>00083   <span class="keyword">inline</span> <span class="keywordtype">long</span> TEMPERING_SHIFT_S(<span class="keyword">const</span> <span class="keywordtype">long</span> y) {
<a name="l00084"></a>00084     <span class="keywordflow">return</span> (y &lt;&lt; 7);
<a name="l00085"></a>00085   }
<a name="l00086"></a>00086   <span class="keyword">inline</span> <span class="keywordtype">long</span> TEMPERING_SHIFT_T(<span class="keyword">const</span> <span class="keywordtype">long</span> y) {
<a name="l00087"></a>00087     <span class="keywordflow">return</span> (y &lt;&lt; 15);
<a name="l00088"></a>00088   }
<a name="l00089"></a>00089   <span class="keyword">inline</span> <span class="keywordtype">long</span> TEMPERING_SHIFT_L(<span class="keyword">const</span> <span class="keywordtype">long</span> y) {
<a name="l00090"></a>00090     <span class="keywordflow">return</span> (y &gt;&gt; 18);
<a name="l00091"></a>00091   }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="comment">// constsnts and function for Kinderman-Ramage standard normal generator</span>
<a name="l00094"></a>00094   <span class="comment">// from R v1.9.0</span>
<a name="l00095"></a>00095   <span class="keyword">const</span> <span class="keywordtype">double</span> C1 = 0.398942280401433;
<a name="l00096"></a>00096   <span class="keyword">const</span> <span class="keywordtype">double</span> C2 = 0.180025191068563;
<a name="l00097"></a>00097   <span class="keyword">const</span> <span class="keywordtype">double</span> A =  2.216035867166471;
<a name="l00098"></a>00098   <span class="keyword">inline</span> <span class="keywordtype">double</span> g(<span class="keyword">const</span> <span class="keywordtype">double</span> x) {
<a name="l00099"></a>00099                 <span class="keywordflow">return</span> (C1*exp(-x*x/2.0)-C2*(A-x));
<a name="l00100"></a>00100   }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <span class="comment">// constants for Poisson generator from R v1.9.0</span>
<a name="l00103"></a>00103   <span class="keyword">const</span> <span class="keywordtype">double</span> a0       = -0.5;
<a name="l00104"></a>00104   <span class="keyword">const</span> <span class="keywordtype">double</span> a1 = 0.3333333;
<a name="l00105"></a>00105   <span class="keyword">const</span> <span class="keywordtype">double</span> a2 =     -0.2500068;
<a name="l00106"></a>00106   <span class="keyword">const</span> <span class="keywordtype">double</span> a3 = 0.2000118;
<a name="l00107"></a>00107   <span class="keyword">const</span> <span class="keywordtype">double</span> a4       = -0.1661269;
<a name="l00108"></a>00108   <span class="keyword">const</span> <span class="keywordtype">double</span> a5 = 0.1421878;
<a name="l00109"></a>00109   <span class="keyword">const</span> <span class="keywordtype">double</span> a6       = -0.1384794;
<a name="l00110"></a>00110   <span class="keyword">const</span> <span class="keywordtype">double</span> a7 = 0.1250060;
<a name="l00111"></a>00111   <span class="keyword">const</span> <span class="keywordtype">double</span> one_7 = 0.1428571428571428571;
<a name="l00112"></a>00112   <span class="keyword">const</span> <span class="keywordtype">double</span> one_12 = 0.0833333333333333333;
<a name="l00113"></a>00113   <span class="keyword">const</span> <span class="keywordtype">double</span> one_24   = 0.0416666666666666667;
<a name="l00114"></a>00114   <span class="keyword">const</span> <span class="keywordtype">double</span> M_1_SQRT_2PI     = 0.398942280401432677939946059934;     <span class="comment">/* 1/sqrt(2pi) */</span>
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   <span class="comment">// From R v2.0</span>
<a name="l00117"></a>00117 <span class="preprocessor">#if defined(M_PI)</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">#undef M_PI</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">double</span> M_PI = 3.141592653589793238462643383280;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   <span class="comment">// computes e^x - 1 more accurately than exp(x) - 1 for small values</span>
<a name="l00123"></a>00123   <span class="comment">// of x, i.e., x &lt;= 0.697</span>
<a name="l00124"></a>00124   <span class="comment">//</span>
<a name="l00125"></a>00125   <span class="comment">// modified from R v1.9.0</span>
<a name="l00126"></a>00126   <span class="comment">/*</span>
<a name="l00127"></a>00127 <span class="comment">   *  Mathlib : A C Library of Special Functions</span>
<a name="l00128"></a>00128 <span class="comment">   *  Copyright (C) 2002 The R Development Core Team</span>
<a name="l00129"></a>00129 <span class="comment">   *</span>
<a name="l00130"></a>00130 <span class="comment">   *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00131"></a>00131 <span class="comment">   *  it under the terms of the GNU General Public License as published by</span>
<a name="l00132"></a>00132 <span class="comment">   *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00133"></a>00133 <span class="comment">   *  (at your option) any later version.</span>
<a name="l00134"></a>00134 <span class="comment">   *</span>
<a name="l00135"></a>00135 <span class="comment">   *  This program is distributed in the hope that it will be useful,</span>
<a name="l00136"></a>00136 <span class="comment">   *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00137"></a>00137 <span class="comment">   *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00138"></a>00138 <span class="comment">   *  GNU General Public License for more details.</span>
<a name="l00139"></a>00139 <span class="comment">   *</span>
<a name="l00140"></a>00140 <span class="comment">   *  You should have received a copy of the GNU General Public License</span>
<a name="l00141"></a>00141 <span class="comment">   *  along with this program; if not, write to the Free Software</span>
<a name="l00142"></a>00142 <span class="comment">   *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l00143"></a>00143 <span class="comment">   *</span>
<a name="l00144"></a>00144 <span class="comment">   *  SYNOPSIS</span>
<a name="l00145"></a>00145 <span class="comment">   *</span>
<a name="l00146"></a>00146 <span class="comment">   *    #include &lt;Rmath.h&gt;</span>
<a name="l00147"></a>00147 <span class="comment">   *    double expm1(double x);</span>
<a name="l00148"></a>00148 <span class="comment">   *</span>
<a name="l00149"></a>00149 <span class="comment">   *  DESCRIPTION</span>
<a name="l00150"></a>00150 <span class="comment">   *</span>
<a name="l00151"></a>00151 <span class="comment">   *    Compute the Exponential minus 1</span>
<a name="l00152"></a>00152 <span class="comment">   *</span>
<a name="l00153"></a>00153 <span class="comment">   *                    exp(x) - 1</span>
<a name="l00154"></a>00154 <span class="comment">   *</span>
<a name="l00155"></a>00155 <span class="comment">   *      accurately also when x is close to zero, i.e. |x| &lt;&lt; 1</span>
<a name="l00156"></a>00156 <span class="comment">   *</span>
<a name="l00157"></a>00157 <span class="comment">   *  NOTES</span>
<a name="l00158"></a>00158 <span class="comment">   *</span>
<a name="l00159"></a>00159 <span class="comment">   *    As log1p(), this is a standard function in some C libraries,</span>
<a name="l00160"></a>00160 <span class="comment">   *    particularly GNU and BSD (but is neither ISO/ANSI C nor POSIX).</span>
<a name="l00161"></a>00161 <span class="comment">   *</span>
<a name="l00162"></a>00162 <span class="comment">   *  We supply a substitute for the case when there is no system one.</span>
<a name="l00163"></a>00163 <span class="comment">   */</span>
<a name="l00164"></a>00164 <span class="preprocessor">#if !defined(HAVE_EXPM1)</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>  <span class="keywordtype">double</span> expm1(<span class="keywordtype">double</span> x) {
<a name="l00166"></a>00166     <span class="keywordtype">double</span> y, a = fabs(x);
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (a &lt; <a class="code" href="namespaceUtil.html#2165720bd22c9f387140ca73396de72a">Util::dbl_eps</a>) {
<a name="l00168"></a>00168       <span class="keywordflow">return</span> x;
<a name="l00169"></a>00169     }
<a name="l00170"></a>00170     <span class="keywordflow">if</span> (a &gt; 0.697) {
<a name="l00171"></a>00171       <span class="keywordflow">return</span> exp(x) - 1;  <span class="comment">/* negligible cancellation */</span>
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173     <span class="keywordflow">if</span> (a &gt; 1e-8) {
<a name="l00174"></a>00174       y = exp(x) - 1;
<a name="l00175"></a>00175     } <span class="keywordflow">else</span> { <span class="comment">/* Taylor expansion, more accurate in this range */</span>
<a name="l00176"></a>00176       y = (x / 2 + 1) * x;
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178     <span class="comment">/* Newton step for solving   log(1 + y) = x   for y : */</span>
<a name="l00179"></a>00179     <span class="comment">/* WARNING: does not work for y ~ -1: bug in 1.5.0 */</span>
<a name="l00180"></a>00180     y -= (1 + y) * (log1p (y) - x);
<a name="l00181"></a>00181     <span class="keywordflow">return</span> y;
<a name="l00182"></a>00182   }
<a name="l00183"></a>00183 <span class="preprocessor">#endif</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>
<a name="l00185"></a>00185   <span class="comment">// From R v2.0</span>
<a name="l00186"></a>00186   <span class="comment">//</span>
<a name="l00187"></a>00187   <span class="comment">// afc(i) :=  ln( i! )        [logarithm of the factorial i.</span>
<a name="l00188"></a>00188   <span class="comment">//       If (i &gt; 7), use Stirling's approximation, otherwise use table lookup.</span>
<a name="l00189"></a>00189   <span class="comment">//</span>
<a name="l00190"></a>00190   <span class="keywordtype">double</span> afc(<span class="keyword">const</span> <span class="keywordtype">int</span> i) {
<a name="l00191"></a>00191     <span class="keyword">const</span> <span class="keywordtype">double</span> al[9] =
<a name="l00192"></a>00192       {
<a name="l00193"></a>00193         0.0,
<a name="l00194"></a>00194         0.0,<span class="comment">/*ln(0!)=ln(1)*/</span>
<a name="l00195"></a>00195         0.0,<span class="comment">/*ln(1!)=ln(1)*/</span>
<a name="l00196"></a>00196         0.69314718055994530941723212145817,<span class="comment">/*ln(2) */</span>
<a name="l00197"></a>00197         1.79175946922805500081247735838070,<span class="comment">/*ln(6) */</span>
<a name="l00198"></a>00198         3.17805383034794561964694160129705,<span class="comment">/*ln(24)*/</span>
<a name="l00199"></a>00199         4.78749174278204599424770093452324,
<a name="l00200"></a>00200         6.57925121201010099506017829290394,
<a name="l00201"></a>00201         8.52516136106541430016553103634712
<a name="l00202"></a>00202         <span class="comment">/*, 10.60460290274525022841722740072165*/</span>
<a name="l00203"></a>00203       };
<a name="l00204"></a>00204     <span class="keywordtype">double</span> di, value;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     <span class="comment">// check eliminated: caller must guarantee i &gt;= 0</span>
<a name="l00207"></a>00207     <span class="comment">//</span>
<a name="l00208"></a>00208     <span class="comment">//     if (i &lt; 0) {</span>
<a name="l00209"></a>00209     <span class="comment">//       MATHLIB_WARNING("rhyper.c: afc(i), i=%d &lt; 0 -- SHOULD NOT HAPPEN!\n",i);</span>
<a name="l00210"></a>00210     <span class="comment">//       return -1;/* unreached (Wall) */</span>
<a name="l00211"></a>00211     <span class="comment">//     } else if (i &lt;= 7) {</span>
<a name="l00212"></a>00212     <span class="keywordflow">if</span> (i &lt;= 7) {
<a name="l00213"></a>00213       value = al[i + 1];
<a name="l00214"></a>00214     } <span class="keywordflow">else</span> {
<a name="l00215"></a>00215       di = i;
<a name="l00216"></a>00216       value = (di + 0.5) * log(di) - di + 0.08333333333333 / di
<a name="l00217"></a>00217         - 0.00277777777777 / di / di / di + 0.9189385332;
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219     <span class="keywordflow">return</span> value;
<a name="l00220"></a>00220   }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 <span class="comment"></span>
<a name="l00224"></a>00224 <span class="comment">/// Default constructor</span>
<a name="l00225"></a>00225 <span class="comment">///</span>
<a name="l00226"></a>00226 <span class="comment">/// Uses Mersenne twister on [0,1) by default and selects integer </span>
<a name="l00227"></a>00227 <span class="comment">/// implementation of Knuth generator by default, using long -&gt; double </span>
<a name="l00228"></a>00228 <span class="comment">/// conversion for uniform on [0,1) instead of direct calculations with</span>
<a name="l00229"></a>00229 <span class="comment">/// floating point</span>
<a name="l00230"></a>00230 <span class="comment">///</span>
<a name="l00231"></a>00231 <span class="comment">/// \param type   RAN_POL (Lewis), RAN_KNU (Knuth), RAN_MT (Mersenne Twister)</span>
<a name="l00232"></a>00232 <span class="comment">/// \param gType  RAN_KNU: PRECISE (floating point), FAST (long -&gt; double)</span>
<a name="l00233"></a>00233 <span class="comment">///                        FAST is default because PRECISE != WITH_ZERO</span>
<a name="l00234"></a>00234 <span class="comment">///               RAN_MT: OPEN (0,1), WITH_ZERO [0,1), ZERO_ONE [0,1]</span>
<a name="l00235"></a>00235 <span class="comment">///</span>
<a name="l00236"></a><a class="code" href="classlot.html#70554760f0e7830722c391412b1f5d39">00236</a> <span class="comment"></span><a class="code" href="classlot.html#70554760f0e7830722c391412b1f5d39">lot::lot</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> type, <span class="keyword">const</span> <span class="keywordtype">int</span> gType) : ix0(1L), ix(1L), mti(MT_N+1), 
<a name="l00237"></a>00237                                             rngType_(type),
<a name="l00238"></a>00238                                             e(0.0), prev_alpha(0.0),
<a name="l00239"></a>00239                                             c1(0.0), c2(0.0), c3(0.0),
<a name="l00240"></a>00240                                             c4(0.0), c5(0.0)
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242   mt.resize(MT_N);
<a name="l00243"></a>00243   <a class="code" href="classlot.html#50b26a2995fc46e0aa87258eca60e767">set_generator</a>(type, gType);
<a name="l00244"></a>00244 }
<a name="l00245"></a>00245 <span class="comment"></span>
<a name="l00246"></a>00246 <span class="comment">/// Destructor</span>
<a name="l00247"></a>00247 <span class="comment">///</span>
<a name="l00248"></a>00248 <span class="comment">/// Currently empty. Nothing to clean up</span>
<a name="l00249"></a>00249 <span class="comment">///</span>
<a name="l00250"></a><a class="code" href="classlot.html#982bfaf7e57aa39b914a6d190e120536">00250</a> <span class="comment"></span><a class="code" href="classlot.html#982bfaf7e57aa39b914a6d190e120536">lot::~lot</a>(<span class="keywordtype">void</span>) {}
<a name="l00251"></a>00251 <span class="comment"></span>
<a name="l00252"></a>00252 <span class="comment">/// Set uniform RNG type</span>
<a name="l00253"></a>00253 <span class="comment">///</span>
<a name="l00254"></a>00254 <span class="comment">/// \param type RAN_POL, RAN_KNU, or RAN_MT</span>
<a name="l00255"></a>00255 <span class="comment">/// \param gType PRECISE or FAST (RAN_KNU)</span>
<a name="l00256"></a>00256 <span class="comment">///              DEFAULT, WITH_ZERO, or ZERO_ONE (RAN_MT)</span>
<a name="l00257"></a>00257 <span class="comment">///</span>
<a name="l00258"></a>00258 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00259"></a><a class="code" href="classlot.html#50b26a2995fc46e0aa87258eca60e767">00259</a> <a class="code" href="classlot.html#50b26a2995fc46e0aa87258eca60e767">lot::set_generator</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> type, <span class="keyword">const</span> <span class="keywordtype">int</span> gType) {
<a name="l00260"></a>00260   e = exp(1.0);
<a name="l00261"></a>00261   ready = <span class="keyword">false</span>;
<a name="l00262"></a>00262   time_t timer;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264   <span class="keywordflow">switch</span>(type) {
<a name="l00265"></a>00265     <span class="keywordflow">case</span> <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e84c8aeea26d779e42d3b1bc6129dfe03">RAN_POL</a>:
<a name="l00266"></a>00266       do_uniform = &amp;lot::POL_uniform;
<a name="l00267"></a>00267       uniform_no_zero_generator = &amp;lot::POL_uniform_open;
<a name="l00268"></a>00268       <a class="code" href="classlot.html#5356b0b77728cddb72f2284149c526b2">randomize</a>();
<a name="l00269"></a>00269       <span class="keywordflow">break</span>;
<a name="l00270"></a>00270     <span class="keywordflow">case</span> <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e5289de684557af32381d31a043831d6e">RAN_KNU</a>:
<a name="l00271"></a>00271       ran_arr_buf.resize(QUALITY);
<a name="l00272"></a>00272       ranf_arr_buf.resize(QUALITY);
<a name="l00273"></a>00273       ran_x.resize(KK);
<a name="l00274"></a>00274       ran_u.resize(KK);
<a name="l00275"></a>00275       <span class="keywordflow">if</span> (gType == <a class="code" href="classlot.html#852401da72a5f5512ad42274e90d4d614fb8f1ae49f0ee4e738d99f067af05f5">PRECISE</a>) {
<a name="l00276"></a>00276         do_uniform = &amp;lot::KNU_uniform;
<a name="l00277"></a>00277       } <span class="keywordflow">else</span> {
<a name="l00278"></a>00278         do_uniform = &amp;lot::KNU_uniform_from_long;
<a name="l00279"></a>00279       }
<a name="l00280"></a>00280       uniform_no_zero_generator = &amp;lot::KNU_uniform;
<a name="l00281"></a>00281       <a class="code" href="classlot.html#48ecacbcadb8023910ab78505ea0f46d">ran_start</a>(static_cast&lt;long&gt;(time(&amp;timer) % (MM - 2)));
<a name="l00282"></a>00282       <a class="code" href="classlot.html#0902e284534fcfda6c82d000b5184c48">ranf_start</a>(static_cast&lt;long&gt;(time(&amp;timer)));
<a name="l00283"></a>00283       ran_arr_sentinel = -1;
<a name="l00284"></a>00284       ranf_arr_sentinel = -1.0;
<a name="l00285"></a>00285       ran_arr_ptr = &amp;ran_arr_sentinel;
<a name="l00286"></a>00286       ranf_arr_ptr = &amp;ranf_arr_sentinel;
<a name="l00287"></a>00287       <span class="keywordflow">break</span>;
<a name="l00288"></a>00288     <span class="keywordflow">case</span> <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e75144acc3a6fa744c97652a4c20e9ea7">RAN_MT</a>:
<a name="l00289"></a>00289       <a class="code" href="classlot.html#2988a17c1bce9f45e6f4bdcb226295d5">Set_MT</a>(gType);
<a name="l00290"></a>00290       uniform_no_zero_generator = &amp;<a class="code" href="classlot.html#17369070dd445895b6cefc1f7c41e7a3">lot::MT_genrand</a>;
<a name="l00291"></a>00291       <a class="code" href="classlot.html#726a24cd6215f27a396c1ee699e0b1a9">MT_sgenrand</a>(time(&amp;timer));
<a name="l00292"></a>00292       <span class="keywordflow">break</span>;
<a name="l00293"></a>00293     <span class="keywordflow">default</span>:
<a name="l00294"></a>00294       cerr &lt;&lt; <span class="stringliteral">"Unrecognized generator type!"</span> &lt;&lt; endl;
<a name="l00295"></a>00295       exit(1);
<a name="l00296"></a>00296   }
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 <span class="comment"></span>
<a name="l00299"></a>00299 <span class="comment">/// Used with RAN_POL to "warm up" generator</span>
<a name="l00300"></a>00300 <span class="comment">///</span>
<a name="l00301"></a>00301 <span class="comment">/// \param spin number of preliminary calls to uniform()</span>
<a name="l00302"></a>00302 <span class="comment">///</span>
<a name="l00303"></a>00303 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00304"></a><a class="code" href="classlot.html#b23c605422dc25fafc5f6056914fd8db">00304</a> <a class="code" href="classlot.html#b23c605422dc25fafc5f6056914fd8db">lot::dememorize</a> (<span class="keywordtype">int</span> spin <span class="comment">/* = 100 */</span> ) {
<a name="l00305"></a>00305   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; spin; k++)
<a name="l00306"></a>00306     <a class="code" href="classlot.html#fb4e34587dc2deca4df5074968385c73">uniform</a>();
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 <span class="comment"></span>
<a name="l00309"></a>00309 <span class="comment">/// Initializes RAN_POL</span>
<a name="l00310"></a>00310 <span class="comment">///</span>
<a name="l00311"></a>00311 <span class="comment">/// \param spin (default 100) passed to dememorize()</span>
<a name="l00312"></a>00312 <span class="comment">///</span>
<a name="l00313"></a>00313 <span class="comment">/// Initializes seeds with current system time and calls dememorize to</span>
<a name="l00314"></a>00314 <span class="comment">/// "warm up" random number generator </span>
<a name="l00315"></a>00315 <span class="comment">///</span>
<a name="l00316"></a>00316 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00317"></a><a class="code" href="classlot.html#5356b0b77728cddb72f2284149c526b2">00317</a> <a class="code" href="classlot.html#5356b0b77728cddb72f2284149c526b2">lot::randomize</a> (<span class="keywordtype">int</span> spin <span class="comment">/* = 100 */</span> ) {
<a name="l00318"></a>00318   time_t timer;
<a name="l00319"></a>00319   ix = ix0 = static_cast&lt;long&gt;(time(&amp;timer));
<a name="l00320"></a>00320   <a class="code" href="classlot.html#b23c605422dc25fafc5f6056914fd8db">dememorize</a> (spin);
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 <span class="comment"></span>
<a name="l00323"></a>00323 <span class="comment">/// Initialize RNG with known seed</span>
<a name="l00324"></a>00324 <span class="comment">///</span>
<a name="l00325"></a>00325 <span class="comment">/// \param s   Seed</span>
<a name="l00326"></a>00326 <span class="comment">///</span>
<a name="l00327"></a>00327 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00328"></a><a class="code" href="classlot.html#942076f8f64562ece9af0f04a2f9ff7b">00328</a> <a class="code" href="classlot.html#942076f8f64562ece9af0f04a2f9ff7b">lot::set_seed</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> s) {
<a name="l00329"></a>00329   <span class="keywordflow">switch</span>(rngType_) {
<a name="l00330"></a>00330     <span class="keywordflow">case</span> <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e84c8aeea26d779e42d3b1bc6129dfe03">RAN_POL</a>:
<a name="l00331"></a>00331       ix = ix0 = s;
<a name="l00332"></a>00332       <span class="keywordflow">break</span>;
<a name="l00333"></a>00333     <span class="keywordflow">case</span> <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e5289de684557af32381d31a043831d6e">RAN_KNU</a>:
<a name="l00334"></a>00334       <a class="code" href="classlot.html#48ecacbcadb8023910ab78505ea0f46d">ran_start</a>(s % (MM - 2));
<a name="l00335"></a>00335       <a class="code" href="classlot.html#0902e284534fcfda6c82d000b5184c48">ranf_start</a>(s);
<a name="l00336"></a>00336       <span class="keywordflow">break</span>;
<a name="l00337"></a>00337     <span class="keywordflow">case</span> <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e75144acc3a6fa744c97652a4c20e9ea7">RAN_MT</a>:
<a name="l00338"></a>00338       <a class="code" href="classlot.html#726a24cd6215f27a396c1ee699e0b1a9">MT_sgenrand</a>(s);
<a name="l00339"></a>00339       <span class="keywordflow">break</span>;
<a name="l00340"></a>00340     <span class="keywordflow">default</span>:
<a name="l00341"></a>00341       cerr &lt;&lt; <span class="stringliteral">"Unrecognized generator type!"</span> &lt;&lt; endl;
<a name="l00342"></a>00342       exit(1);
<a name="l00343"></a>00343   }
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 <span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment">/// Set MT type </span>
<a name="l00347"></a>00347 <span class="comment">///</span>
<a name="l00348"></a>00348 <span class="comment">/// \param type  DEFAULT (0,1), ZERO [0,1), ZERO_ONE [0,1]</span>
<a name="l00349"></a>00349 <span class="comment">///</span>
<a name="l00350"></a>00350 <span class="comment">/// Leaves MT type unchanged if type is not one of DEFAULT, ZERO, or</span>
<a name="l00351"></a>00351 <span class="comment">/// ZERO_ONE. Changes from RAN_POL or RAN_KNU to RAN_MT.</span>
<a name="l00352"></a>00352 <span class="comment">///</span>
<a name="l00353"></a>00353 <span class="comment"></span><span class="keywordtype">bool</span> 
<a name="l00354"></a><a class="code" href="classlot.html#2988a17c1bce9f45e6f4bdcb226295d5">00354</a> <a class="code" href="classlot.html#2988a17c1bce9f45e6f4bdcb226295d5">lot::Set_MT</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> type) {
<a name="l00355"></a>00355   <span class="keywordtype">bool</span> retval = <span class="keyword">true</span>;
<a name="l00356"></a>00356   <span class="keywordflow">switch</span> (type) {
<a name="l00357"></a>00357     <span class="keywordflow">case</span> <a class="code" href="classlot.html#5775cbd2ae1178bf3ed02649058732bb02275dacc38a4ef5c7506fd49da46c20">OPEN</a>:
<a name="l00358"></a>00358       do_uniform = &amp;<a class="code" href="classlot.html#17369070dd445895b6cefc1f7c41e7a3">lot::MT_genrand</a>;
<a name="l00359"></a>00359       rngType_ = <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e75144acc3a6fa744c97652a4c20e9ea7">lot::RAN_MT</a>;
<a name="l00360"></a>00360       <span class="keywordflow">break</span>;
<a name="l00361"></a>00361     <span class="keywordflow">case</span> <a class="code" href="classlot.html#5775cbd2ae1178bf3ed02649058732bbad18a6488861f575d0b0443b52d3ae07">ZERO</a>:
<a name="l00362"></a>00362       do_uniform = &amp;<a class="code" href="classlot.html#009c1e57a4716153b28734b279e67f82">lot::MT_genrand_with_zero</a>;
<a name="l00363"></a>00363       rngType_ = <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e75144acc3a6fa744c97652a4c20e9ea7">lot::RAN_MT</a>;
<a name="l00364"></a>00364       <span class="keywordflow">break</span>;
<a name="l00365"></a>00365     <span class="keywordflow">case</span> <a class="code" href="classlot.html#5775cbd2ae1178bf3ed02649058732bb6ee4f056bd712e52b211d8241228c5d2">ZERO_ONE</a>:
<a name="l00366"></a>00366       do_uniform = &amp;<a class="code" href="classlot.html#e39c9e6233d2865f0b51db08a0ab8515">lot::MT_genrand_with_zero_one</a>;
<a name="l00367"></a>00367       rngType_ = <a class="code" href="classlot.html#065d0410644b293166250bbce85e068e75144acc3a6fa744c97652a4c20e9ea7">lot::RAN_MT</a>;
<a name="l00368"></a>00368       <span class="keywordflow">break</span>;
<a name="l00369"></a>00369     <span class="keywordflow">default</span>:
<a name="l00370"></a>00370       retval = <span class="keyword">false</span>;
<a name="l00371"></a>00371       <span class="keywordflow">break</span>;
<a name="l00372"></a>00372   }
<a name="l00373"></a>00373   <span class="keywordflow">return</span> retval;
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 <span class="comment"></span>
<a name="l00376"></a>00376 <span class="comment">/// Double implementation of Knuth generator</span>
<a name="l00377"></a>00377 <span class="comment">///</span>
<a name="l00378"></a>00378 <span class="comment">/// From the source to rng-double.c:</span>
<a name="l00379"></a>00379 <span class="comment">///</span>
<a name="l00380"></a>00380 <span class="comment">///   This program by D E Knuth is in the public domain and freely copyable</span>
<a name="l00381"></a>00381 <span class="comment">///   AS LONG AS YOU MAKE ABSOLUTELY NO CHANGES!</span>
<a name="l00382"></a>00382 <span class="comment">///   It is explained in Seminumerical Algorithms, 3rd edition, Section 3.6</span>
<a name="l00383"></a>00383 <span class="comment">///  (or in the errata to the 2nd edition --- see</span>
<a name="l00384"></a>00384 <span class="comment">///   http://www-cs-faculty.stanford.edu/~knuth/taocp.html</span>
<a name="l00385"></a>00385 <span class="comment">///  in the changes to Volume 2 on pages 171 and following).</span>
<a name="l00386"></a>00386 <span class="comment">///</span>
<a name="l00387"></a>00387 <span class="comment">///   N.B. The MODIFICATIONS introduced in the 9th printing (2002) are</span>
<a name="l00388"></a>00388 <span class="comment">///   included here; there's no backwards compatibility with the original.</span>
<a name="l00389"></a>00389 <span class="comment">///</span>
<a name="l00390"></a>00390 <span class="comment">///   If you find any bugs, please report them immediately to</span>
<a name="l00391"></a>00391 <span class="comment">///   taocp@cs.stanford.edu</span>
<a name="l00392"></a>00392 <span class="comment">///   (and you will be rewarded if the bug is genuine). Thanks!</span>
<a name="l00393"></a>00393 <span class="comment">///</span>
<a name="l00394"></a>00394 <span class="comment">/// see the book for explanations and caveats!</span>
<a name="l00395"></a>00395 <span class="comment">/// particular, you need two's complement arithmetic</span>
<a name="l00396"></a>00396 <span class="comment">///</span>
<a name="l00397"></a>00397 <span class="comment">/// Note: This method is private.</span>
<a name="l00398"></a>00398 <span class="comment">///</span>
<a name="l00399"></a>00399 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l00400"></a>00400 lot::KNU_uniform(<span class="keywordtype">void</span>) {
<a name="l00401"></a>00401   <span class="keywordflow">return</span> *ranf_arr_ptr &gt;= 0 ? *ranf_arr_ptr++ : ranf_arr_cycle();
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 <span class="comment"></span>
<a name="l00404"></a>00404 <span class="comment">/// Updates floating point array of Knuth generator</span>
<a name="l00405"></a>00405 <span class="comment">///</span>
<a name="l00406"></a>00406 <span class="comment">/// \param aa  the vector of values in which to update</span>
<a name="l00407"></a>00407 <span class="comment">/// \param n   the number of values to update, note n == aa.size() assumed</span>
<a name="l00408"></a>00408 <span class="comment">///</span>
<a name="l00409"></a>00409 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00410"></a><a class="code" href="classlot.html#ab474f8158a529dd301fdd5274532fd1">00410</a> <a class="code" href="classlot.html#ab474f8158a529dd301fdd5274532fd1">lot::ranf_array</a>(std::vector&lt;double&gt;&amp; aa, <span class="keywordtype">int</span> n) {
<a name="l00411"></a>00411   <span class="keywordtype">int</span> i, j;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="keywordflow">for</span> (j = 0; j &lt; KK; j++) {
<a name="l00414"></a>00414     aa[j] = ran_u[j];
<a name="l00415"></a>00415   }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keywordflow">for</span> (; j &lt; n; j++) {
<a name="l00418"></a>00418     aa[j] = mod_sum(aa[j - KK], aa[j - LL]);
<a name="l00419"></a>00419   }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421   <span class="keywordflow">for</span> (i = 0; i &lt; LL; i++, j++) {
<a name="l00422"></a>00422     ran_u[i] = mod_sum(aa[j - KK], aa[j - LL]);
<a name="l00423"></a>00423   }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="keywordflow">for</span> (; i &lt; KK; i++, j++) {
<a name="l00426"></a>00426     ran_u[i] = mod_sum(aa[j - KK], ran_u[i - LL]);
<a name="l00427"></a>00427   }
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 <span class="comment"></span>
<a name="l00430"></a>00430 <span class="comment">/// Cycle the Knuth double RNG</span>
<a name="l00431"></a>00431 <span class="comment">///</span>
<a name="l00432"></a>00432 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l00433"></a>00433 lot::ranf_arr_cycle(<span class="keywordtype">void</span>) {
<a name="l00434"></a>00434   <a class="code" href="classlot.html#ab474f8158a529dd301fdd5274532fd1">ranf_array</a>(ranf_arr_buf, QUALITY);
<a name="l00435"></a>00435   ranf_arr_buf[100] = -1;
<a name="l00436"></a>00436   ranf_arr_ptr = &amp;ranf_arr_buf[1];
<a name="l00437"></a>00437   <span class="keywordflow">return</span> ranf_arr_buf[0];
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 <span class="comment"></span>
<a name="l00440"></a>00440 <span class="comment">/// Initialize the Knuth double RNG</span>
<a name="l00441"></a>00441 <span class="comment">///</span>
<a name="l00442"></a>00442 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00443"></a><a class="code" href="classlot.html#0902e284534fcfda6c82d000b5184c48">00443</a> <a class="code" href="classlot.html#0902e284534fcfda6c82d000b5184c48">lot::ranf_start</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> seed) {
<a name="l00444"></a>00444   <span class="keywordtype">int</span> <a class="code" href="classlot.html#2c92917eba7874183e6f3672c9ac2f61">t</a>, s, j;
<a name="l00445"></a>00445   vector&lt;double&gt; u(KK + KK - 1);
<a name="l00446"></a>00446   <span class="keywordtype">double</span> ulp = (1.0 / (1L &lt;&lt; 30)) / (1L &lt;&lt; 22);               <span class="comment">/* 2 to the -52 */</span>
<a name="l00447"></a>00447   <span class="keywordtype">double</span> ss = 2.0 * ulp * ((seed &amp; 0x3fffffff) + 2);
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   <span class="keywordflow">for</span> (j = 0;j &lt; KK;j++) {
<a name="l00450"></a>00450     u[j] = ss;                                <span class="comment">/* bootstrap the buffer */</span>
<a name="l00451"></a>00451     ss += ss;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <span class="keywordflow">if</span> (ss &gt;= 1.0)
<a name="l00454"></a>00454       ss -= 1.0 - 2 * ulp;  <span class="comment">/* cyclic shift of 51 bits */</span>
<a name="l00455"></a>00455   }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   u[1] += ulp;                     <span class="comment">/* make u[1] (and only u[1]) "odd" */</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459   <span class="keywordflow">for</span> (s = seed &amp; 0x3fffffff, t = TT - 1; t; ) {
<a name="l00460"></a>00460     <span class="keywordflow">for</span> (j = KK - 1;j &gt; 0;j--)
<a name="l00461"></a>00461       u[j + j] = u[j], u[j + j - 1] = 0.0;                         <span class="comment">/* "square" */</span>
<a name="l00462"></a>00462 
<a name="l00463"></a>00463     <span class="keywordflow">for</span> (j = KK + KK - 2;j &gt;= KK;j--) {
<a name="l00464"></a>00464       u[j - (KK - LL)] = mod_sum(u[j - (KK - LL)], u[j]);
<a name="l00465"></a>00465       u[j - KK] = mod_sum(u[j - KK], u[j]);
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468     <span class="keywordflow">if</span> (is_odd(s)) {                             <span class="comment">/* "multiply by z" */</span>
<a name="l00469"></a>00469 
<a name="l00470"></a>00470       <span class="keywordflow">for</span> (j = KK;j &gt; 0;j--)
<a name="l00471"></a>00471         u[j] = u[j - 1];
<a name="l00472"></a>00472 
<a name="l00473"></a>00473       u[0] = u[KK];                    <span class="comment">/* shift the buffer cyclically */</span>
<a name="l00474"></a>00474 
<a name="l00475"></a>00475       u[LL] = mod_sum(u[LL], u[KK]);
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478     <span class="keywordflow">if</span> (s)
<a name="l00479"></a>00479       s &gt;&gt;= 1;
<a name="l00480"></a>00480     <span class="keywordflow">else</span>
<a name="l00481"></a>00481       t--;
<a name="l00482"></a>00482   }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484   <span class="keywordflow">for</span> (j = 0;j &lt; LL;j++)
<a name="l00485"></a>00485     ran_u[j + KK - LL] = u[j];
<a name="l00486"></a>00486 
<a name="l00487"></a>00487   <span class="keywordflow">for</span> (;j &lt; KK;j++)
<a name="l00488"></a>00488     ran_u[j - LL] = u[j];
<a name="l00489"></a>00489 
<a name="l00490"></a>00490   <span class="keywordflow">for</span> (j = 0;j &lt; 10;j++)
<a name="l00491"></a>00491     <a class="code" href="classlot.html#ab474f8158a529dd301fdd5274532fd1">ranf_array</a>(u, KK + KK - 1);  <span class="comment">/* warm things up */</span>
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   ranf_arr_ptr = &amp;ranf_arr_sentinel;
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 <span class="comment"></span>
<a name="l00496"></a>00496 <span class="comment">/// long implementation of Knuth generator</span>
<a name="l00497"></a>00497 <span class="comment">///</span>
<a name="l00498"></a>00498 <span class="comment">/// From the source to rng.c</span>
<a name="l00499"></a>00499 <span class="comment">///</span>
<a name="l00500"></a>00500 <span class="comment">/// This program by D E Knuth is in the public domain and freely copyable</span>
<a name="l00501"></a>00501 <span class="comment">/// AS LONG AS YOU MAKE ABSOLUTELY NO CHANGES!</span>
<a name="l00502"></a>00502 <span class="comment">/// It is explained in Seminumerical Algorithms, 3rd edition, Section 3.6</span>
<a name="l00503"></a>00503 <span class="comment">/// (or in the errata to the 2nd edition --- see</span>
<a name="l00504"></a>00504 <span class="comment">/// http://www-cs-faculty.stanford.edu/~knuth/taocp.html</span>
<a name="l00505"></a>00505 <span class="comment">/// in the changes to Volume 2 on pages 171 and following).</span>
<a name="l00506"></a>00506 <span class="comment">///</span>
<a name="l00507"></a>00507 <span class="comment">/// N.B. The MODIFICATIONS introduced in the 9th printing (2002) are</span>
<a name="l00508"></a>00508 <span class="comment">/// included here; there's no backwards compatibility with the original.</span>
<a name="l00509"></a>00509 <span class="comment">///</span>
<a name="l00510"></a>00510 <span class="comment">/// If you find any bugs, please report them immediately to</span>
<a name="l00511"></a>00511 <span class="comment">/// taocp@cs.stanford.edu</span>
<a name="l00512"></a>00512 <span class="comment">/// and you will be rewarded if the bug is genuine). Thanks!</span>
<a name="l00513"></a>00513 <span class="comment">///</span>
<a name="l00514"></a>00514 <span class="comment">/// see the book for explanations and caveats!</span>
<a name="l00515"></a>00515 <span class="comment">/// in particular, you need two's complement arithmetic</span>
<a name="l00516"></a>00516 <span class="comment">///</span>
<a name="l00517"></a>00517 <span class="comment">/// NOTE: Knuth is not responsible for the implementation of </span>
<a name="l00518"></a>00518 <span class="comment">/// KNU_uniform_from_long(). If there's an error in that it's my fault.</span>
<a name="l00519"></a>00519 <span class="comment">///</span>
<a name="l00520"></a>00520 <span class="comment">/// Note: This method is private.</span>
<a name="l00521"></a>00521 <span class="comment">///</span>
<a name="l00522"></a>00522 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l00523"></a>00523 lot::KNU_uniform_from_long(<span class="keywordtype">void</span>) {
<a name="l00524"></a>00524   <span class="keywordflow">return</span> <a class="code" href="classlot.html#c17b449e51cec7ed667a8236edfe1f6f">ran_knu</a>() / static_cast&lt;double&gt;(MM);
<a name="l00525"></a>00525 }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 <span class="comment"></span>
<a name="l00528"></a>00528 <span class="comment">/// Updates long array of Knuth generator</span>
<a name="l00529"></a>00529 <span class="comment">///</span>
<a name="l00530"></a>00530 <span class="comment">/// \param aa  the vector of values in which to update</span>
<a name="l00531"></a>00531 <span class="comment">/// \param n   the number of values to update, note n == aa.size() assumed</span>
<a name="l00532"></a>00532 <span class="comment">///</span>
<a name="l00533"></a>00533 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00534"></a><a class="code" href="classlot.html#430b714e15ef704de7f5bf94ace2beae">00534</a> <a class="code" href="classlot.html#430b714e15ef704de7f5bf94ace2beae">lot::ran_array</a>(std::vector&lt;long&gt;&amp; aa, <span class="keyword">const</span> <span class="keywordtype">int</span> n) {
<a name="l00535"></a>00535   <span class="keywordtype">int</span> i, j;
<a name="l00536"></a>00536 
<a name="l00537"></a>00537   <span class="keywordflow">for</span> (j = 0; j &lt; KK; j++) {
<a name="l00538"></a>00538     aa[j] = ran_x[j];
<a name="l00539"></a>00539   }
<a name="l00540"></a>00540 
<a name="l00541"></a>00541   <span class="keywordflow">for</span> (; j &lt; n; j++) {
<a name="l00542"></a>00542     aa[j] = mod_diff(aa[j - KK], aa[j - LL]);
<a name="l00543"></a>00543   }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keywordflow">for</span> (i = 0; i &lt; LL; i++, j++) {
<a name="l00546"></a>00546     ran_x[i] = mod_diff(aa[j - KK], aa[j - LL]);
<a name="l00547"></a>00547   }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="keywordflow">for</span> (; i &lt; KK; i++, j++) {
<a name="l00550"></a>00550     ran_x[i] = mod_diff(aa[j - KK], ran_x[i - LL]);
<a name="l00551"></a>00551   }
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 <span class="comment"></span>
<a name="l00554"></a>00554 <span class="comment">/// Cycle the Knuth long RNG</span>
<a name="l00555"></a>00555 <span class="comment">///</span>
<a name="l00556"></a>00556 <span class="comment"></span><span class="keywordtype">long</span>
<a name="l00557"></a>00557 lot::ran_arr_cycle() {
<a name="l00558"></a>00558   <a class="code" href="classlot.html#430b714e15ef704de7f5bf94ace2beae">ran_array</a>(ran_arr_buf, QUALITY);
<a name="l00559"></a>00559   ran_arr_buf[100] = -1;
<a name="l00560"></a>00560   ran_arr_ptr = &amp;ran_arr_buf[1];
<a name="l00561"></a>00561   <span class="keywordflow">return</span> ran_arr_buf[0];
<a name="l00562"></a>00562 }
<a name="l00563"></a>00563 <span class="comment"></span>
<a name="l00564"></a>00564 <span class="comment">/// Initialize the Knuth long RNG</span>
<a name="l00565"></a>00565 <span class="comment">///</span>
<a name="l00566"></a>00566 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00567"></a><a class="code" href="classlot.html#48ecacbcadb8023910ab78505ea0f46d">00567</a> <a class="code" href="classlot.html#48ecacbcadb8023910ab78505ea0f46d">lot::ran_start</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> seed) {
<a name="l00568"></a>00568   <span class="keywordtype">int</span> <a class="code" href="classlot.html#2c92917eba7874183e6f3672c9ac2f61">t</a>, j;
<a name="l00569"></a>00569   vector&lt;long&gt; x(KK + KK - 1);  <span class="comment">// the preparation buffer</span>
<a name="l00570"></a>00570   <span class="keywordtype">long</span> ss = (seed + 2) &amp; (MM - 2);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572   <span class="keywordflow">for</span> (j = 0;j &lt; KK;j++) {
<a name="l00573"></a>00573     x[j] = ss;                      <span class="comment">/* bootstrap the buffer */</span>
<a name="l00574"></a>00574     ss &lt;&lt;= 1;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     <span class="keywordflow">if</span> (ss &gt;= MM)
<a name="l00577"></a>00577       ss -= MM - 2; <span class="comment">/* cyclic shift 29 bits */</span>
<a name="l00578"></a>00578   }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580   x[1]++;              <span class="comment">/* make x[1] (and only x[1]) odd */</span>
<a name="l00581"></a>00581 
<a name="l00582"></a>00582   <span class="keywordflow">for</span> (ss = seed &amp; (MM - 1), t = TT - 1; t; ) {
<a name="l00583"></a>00583     <span class="keywordflow">for</span> (j = KK - 1;j &gt; 0;j--)
<a name="l00584"></a>00584       x[j + j] = x[j], x[j + j - 1] = 0; <span class="comment">/* "square" */</span>
<a name="l00585"></a>00585 
<a name="l00586"></a>00586     <span class="keywordflow">for</span> (j = KK + KK - 2;j &gt;= KK;j--)
<a name="l00587"></a>00587       x[j - (KK - LL)] = mod_diff(x[j - (KK - LL)], x[j]),
<a name="l00588"></a>00588                          x[j - KK] = mod_diff(x[j - KK], x[j]);
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     <span class="keywordflow">if</span> (is_odd(ss)) {              <span class="comment">/* "multiply by z" */</span>
<a name="l00591"></a>00591 
<a name="l00592"></a>00592       <span class="keywordflow">for</span> (j = KK;j &gt; 0;j--)
<a name="l00593"></a>00593         x[j] = x[j - 1];
<a name="l00594"></a>00594 
<a name="l00595"></a>00595       x[0] = x[KK];            <span class="comment">/* shift the buffer cyclically */</span>
<a name="l00596"></a>00596 
<a name="l00597"></a>00597       x[LL] = mod_diff(x[LL], x[KK]);
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     <span class="keywordflow">if</span> (ss)
<a name="l00601"></a>00601       ss &gt;&gt;= 1;
<a name="l00602"></a>00602     <span class="keywordflow">else</span>
<a name="l00603"></a>00603       t--;
<a name="l00604"></a>00604   }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="keywordflow">for</span> (j = 0;j &lt; LL;j++)
<a name="l00607"></a>00607     ran_x[j + KK - LL] = x[j];
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   <span class="keywordflow">for</span> (;j &lt; KK;j++)
<a name="l00610"></a>00610     ran_x[j - LL] = x[j];
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="keywordflow">for</span> (j = 0;j &lt; 10;j++)
<a name="l00613"></a>00613     <a class="code" href="classlot.html#430b714e15ef704de7f5bf94ace2beae">ran_array</a>(x, KK + KK - 1); <span class="comment">/* warm things up */</span>
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   ran_arr_ptr = &amp;ran_arr_sentinel;
<a name="l00616"></a>00616 }
<a name="l00617"></a>00617 <span class="comment"></span>
<a name="l00618"></a>00618 <span class="comment">/// Paul Lewis' RNG</span>
<a name="l00619"></a>00619 <span class="comment">///</span>
<a name="l00620"></a>00620 <span class="comment">/// Uniform pseudorandom number generator</span>
<a name="l00621"></a>00621 <span class="comment">/// Provided by J. Monahan, Statistics Dept., N.C. State University</span>
<a name="l00622"></a>00622 <span class="comment">/// From Schrage, ACM Trans. Math. Software 5:132-138 (1979)</span>
<a name="l00623"></a>00623 <span class="comment">/// Translated to C by Paul O. Lewis, Dec. 10, 1992</span>
<a name="l00624"></a>00624 <span class="comment">///</span>
<a name="l00625"></a>00625 <span class="comment">/// Note: this method is private</span>
<a name="l00626"></a>00626 <span class="comment">///</span>
<a name="l00627"></a>00627 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l00628"></a>00628 lot::POL_uniform() {
<a name="l00629"></a>00629   <span class="keywordtype">long</span> a, p, b15, b16, xhi, xalo, leftlo, fhi, k;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   a = 16807L;
<a name="l00632"></a>00632   b15 = 32768L;
<a name="l00633"></a>00633   b16 = 65536L;
<a name="l00634"></a>00634   p = 2147483647L;
<a name="l00635"></a>00635   xhi = ix / b16;
<a name="l00636"></a>00636   xalo = (ix - xhi * b16) * a;
<a name="l00637"></a>00637   leftlo = xalo / b16;
<a name="l00638"></a>00638   fhi = xhi * a + leftlo;
<a name="l00639"></a>00639   k = fhi / b15;
<a name="l00640"></a>00640   ix = (((xalo - leftlo * b16) - p) + (fhi - k * b15) * b16) + k;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642   <span class="keywordflow">if</span> (ix &lt; 0) {
<a name="l00643"></a>00643     ix += p;
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645   <span class="keywordflow">return</span> ix * 4.6566128575e-10;
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 <span class="comment"></span>
<a name="l00648"></a>00648 <span class="comment">/// Paul's RNG modified to ensure non-zero return</span>
<a name="l00649"></a>00649 <span class="comment">/// Note: this method is private</span>
<a name="l00650"></a>00650 <span class="comment">///</span>
<a name="l00651"></a>00651 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l00652"></a>00652 lot::POL_uniform_open() {
<a name="l00653"></a>00653   <span class="keywordtype">long</span> a, p, b15, b16, xhi, xalo, leftlo, fhi, k;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="keywordflow">do</span> {
<a name="l00656"></a>00656     a = 16807L;
<a name="l00657"></a>00657     b15 = 32768L;
<a name="l00658"></a>00658     b16 = 65536L;
<a name="l00659"></a>00659     p = 2147483647L;
<a name="l00660"></a>00660     xhi = ix / b16;
<a name="l00661"></a>00661     xalo = (ix - xhi * b16) * a;
<a name="l00662"></a>00662     leftlo = xalo / b16;
<a name="l00663"></a>00663     fhi = xhi * a + leftlo;
<a name="l00664"></a>00664     k = fhi / b15;
<a name="l00665"></a>00665     ix = (((xalo - leftlo * b16) - p) + (fhi - k * b15) * b16) + k;
<a name="l00666"></a>00666     
<a name="l00667"></a>00667     <span class="keywordflow">if</span> (ix &lt; 0) {
<a name="l00668"></a>00668       ix += p;
<a name="l00669"></a>00669     }
<a name="l00670"></a>00670   } <span class="keywordflow">while</span> (ix == 0);
<a name="l00671"></a>00671   <span class="keywordflow">return</span> ix * 4.6566128575e-10;
<a name="l00672"></a>00672 }
<a name="l00673"></a>00673 <span class="comment"></span>
<a name="l00674"></a>00674 <span class="comment">/// Initializes Mersenne twister RNG</span>
<a name="l00675"></a>00675 <span class="comment">///</span>
<a name="l00676"></a>00676 <span class="comment">/// \param seed </span>
<a name="l00677"></a>00677 <span class="comment">///</span>
<a name="l00678"></a>00678 <span class="comment">/// This code is translated directly from:</span>
<a name="l00679"></a>00679 <span class="comment">///</span>
<a name="l00680"></a>00680 <span class="comment">///   http://www.math.keio.ac.jp/matumoto/CODES/MT2002/mt19937ar.c</span>
<a name="l00681"></a>00681 <span class="comment">///</span>
<a name="l00682"></a>00682 <span class="comment">/// Here are the accompanying comments</span>
<a name="l00683"></a>00683 <span class="comment">/// </span>
<a name="l00684"></a>00684 <span class="comment">/// A C-program for MT19937, with initialization improved 2002/1/26.</span>
<a name="l00685"></a>00685 <span class="comment">/// Coded by Takuji Nishimura and Makoto Matsumoto.</span>
<a name="l00686"></a>00686 <span class="comment">///</span>
<a name="l00687"></a>00687 <span class="comment">/// Before using, initialize the state by using init_genrand(seed)  </span>
<a name="l00688"></a>00688 <span class="comment">/// or init_by_array(init_key, key_length).</span>
<a name="l00689"></a>00689 <span class="comment">///</span>
<a name="l00690"></a>00690 <span class="comment">/// Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,</span>
<a name="l00691"></a>00691 <span class="comment">/// All rights reserved.                          </span>
<a name="l00692"></a>00692 <span class="comment">///</span>
<a name="l00693"></a>00693 <span class="comment">/// Redistribution and use in source and binary forms, with or without</span>
<a name="l00694"></a>00694 <span class="comment">/// modification, are permitted provided that the following conditions</span>
<a name="l00695"></a>00695 <span class="comment">/// are met:</span>
<a name="l00696"></a>00696 <span class="comment">///</span>
<a name="l00697"></a>00697 <span class="comment">/// 1. Redistributions of source code must retain the above copyright</span>
<a name="l00698"></a>00698 <span class="comment">///    notice, this list of conditions and the following disclaimer.</span>
<a name="l00699"></a>00699 <span class="comment">///</span>
<a name="l00700"></a>00700 <span class="comment">/// 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00701"></a>00701 <span class="comment">///    notice, this list of conditions and the following disclaimer in the</span>
<a name="l00702"></a>00702 <span class="comment">///    documentation and/or other materials provided with the distribution.</span>
<a name="l00703"></a>00703 <span class="comment">///</span>
<a name="l00704"></a>00704 <span class="comment">/// 3. The names of its contributors may not be used to endorse or promote </span>
<a name="l00705"></a>00705 <span class="comment">///    products derived from this software without specific prior written </span>
<a name="l00706"></a>00706 <span class="comment">///    permission.</span>
<a name="l00707"></a>00707 <span class="comment">///</span>
<a name="l00708"></a>00708 <span class="comment">/// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00709"></a>00709 <span class="comment">/// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00710"></a>00710 <span class="comment">/// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00711"></a>00711 <span class="comment">/// A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span>
<a name="l00712"></a>00712 <span class="comment">/// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
<a name="l00713"></a>00713 <span class="comment">/// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
<a name="l00714"></a>00714 <span class="comment">/// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<a name="l00715"></a>00715 <span class="comment">/// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<a name="l00716"></a>00716 <span class="comment">/// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00717"></a>00717 <span class="comment">/// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00718"></a>00718 <span class="comment">/// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00719"></a>00719 <span class="comment">///</span>
<a name="l00720"></a>00720 <span class="comment">/// Any feedback is very welcome.</span>
<a name="l00721"></a>00721 <span class="comment">/// http://www.math.keio.ac.jp/matumoto/emt.html</span>
<a name="l00722"></a>00722 <span class="comment">/// email: matumoto@math.keio.ac.jp</span>
<a name="l00723"></a>00723 <span class="comment">///</span>
<a name="l00724"></a>00724 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00725"></a><a class="code" href="classlot.html#726a24cd6215f27a396c1ee699e0b1a9">00725</a> <a class="code" href="classlot.html#726a24cd6215f27a396c1ee699e0b1a9">lot::MT_sgenrand</a>(<span class="keywordtype">long</span> seed) {
<a name="l00726"></a>00726   mt[0]= seed &amp; 0xffffffffUL;
<a name="l00727"></a>00727   <span class="keywordflow">for</span> (mti = 1; mti &lt; MT_N; mti++) {
<a name="l00728"></a>00728     mt[mti] = 
<a name="l00729"></a>00729             (1812433253UL * (mt[mti-1] ^ (mt[mti-1] &gt;&gt; 30)) + mti); 
<a name="l00730"></a>00730     <span class="comment">/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */</span>
<a name="l00731"></a>00731     <span class="comment">/* In the previous versions, MSBs of the seed affect   */</span>
<a name="l00732"></a>00732     <span class="comment">/* only MSBs of the array mt[].                        */</span>
<a name="l00733"></a>00733     <span class="comment">/* 2002/01/09 modified by Makoto Matsumoto             */</span>
<a name="l00734"></a>00734     mt[mti] &amp;= 0xffffffffUL;
<a name="l00735"></a>00735     <span class="comment">/* for &gt;32 bit machines */</span>
<a name="l00736"></a>00736   }
<a name="l00737"></a>00737 }
<a name="l00738"></a>00738 <span class="comment"></span>
<a name="l00739"></a>00739 <span class="comment">/// Initialize Mersenne twister with an array</span>
<a name="l00740"></a>00740 <span class="comment">///</span>
<a name="l00741"></a>00741 <span class="comment">/// \param init_key is the array for initializing keys</span>
<a name="l00742"></a>00742 <span class="comment">/// \param key_length is its length</span>
<a name="l00743"></a>00743 <span class="comment">///</span>
<a name="l00744"></a>00744 <span class="comment"></span><span class="keywordtype">void</span> 
<a name="l00745"></a><a class="code" href="classlot.html#2e5a7b9ecca0071e002110e2f1d4ebbd">00745</a> <a class="code" href="classlot.html#2e5a7b9ecca0071e002110e2f1d4ebbd">lot::MT_init_by_array</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* init_key, <span class="keywordtype">int</span> key_length) {
<a name="l00746"></a>00746   <span class="keywordtype">int</span> i, j, k;
<a name="l00747"></a>00747   <a class="code" href="classlot.html#726a24cd6215f27a396c1ee699e0b1a9">MT_sgenrand</a>(19650218UL);
<a name="l00748"></a>00748   i=1; 
<a name="l00749"></a>00749   j=0;
<a name="l00750"></a>00750   k = (MT_N &gt; key_length ? MT_N : key_length);
<a name="l00751"></a>00751   <span class="keywordflow">for</span> (; k; k--) {
<a name="l00752"></a>00752     mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] &gt;&gt; 30)) * 1664525UL))
<a name="l00753"></a>00753       + init_key[j] + j; <span class="comment">/* non linear */</span>
<a name="l00754"></a>00754     mt[i] &amp;= 0xffffffffUL; <span class="comment">/* for WORDSIZE &gt; 32 machines */</span>
<a name="l00755"></a>00755     i++; 
<a name="l00756"></a>00756     j++;
<a name="l00757"></a>00757     <span class="keywordflow">if</span> (i &gt;= MT_N) { 
<a name="l00758"></a>00758       mt[0] = mt[MT_N-1]; i=1; 
<a name="l00759"></a>00759     }
<a name="l00760"></a>00760     <span class="keywordflow">if</span> (j &gt;= key_length) {
<a name="l00761"></a>00761       j=0;
<a name="l00762"></a>00762     }
<a name="l00763"></a>00763   }
<a name="l00764"></a>00764   <span class="keywordflow">for</span> (k = MT_N-1; k; k--) {
<a name="l00765"></a>00765     mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] &gt;&gt; 30)) * 1566083941UL))
<a name="l00766"></a>00766       - i; <span class="comment">/* non linear */</span>
<a name="l00767"></a>00767     mt[i] &amp;= 0xffffffffUL; <span class="comment">/* for WORDSIZE &gt; 32 machines */</span>
<a name="l00768"></a>00768     i++;
<a name="l00769"></a>00769     <span class="keywordflow">if</span> (i &gt;= MT_N) { 
<a name="l00770"></a>00770       mt[0] = mt[MT_N-1]; 
<a name="l00771"></a>00771       i=1; 
<a name="l00772"></a>00772     }
<a name="l00773"></a>00773   }
<a name="l00774"></a>00774   
<a name="l00775"></a>00775   mt[0] = 0x80000000UL; <span class="comment">/* MSB is 1; assuring non-zero initial array */</span> 
<a name="l00776"></a>00776 }
<a name="l00777"></a>00777 <span class="comment"></span>
<a name="l00778"></a>00778 <span class="comment">/// Initialize array directly with algorithm from R</span>
<a name="l00779"></a>00779 <span class="comment">///</span>
<a name="l00780"></a>00780 <span class="comment">/// \param seed</span>
<a name="l00781"></a>00781 <span class="comment">///</span>
<a name="l00782"></a>00782 <span class="comment">/// Probably useful only for testing purposes. I wrote it to allow me to</span>
<a name="l00783"></a>00783 <span class="comment">/// check norm(), binom(), beta(), etc. against R. It only produces the</span>
<a name="l00784"></a>00784 <span class="comment">/// same sequence as R when seed == 1.</span>
<a name="l00785"></a>00785 <span class="comment">///</span>
<a name="l00786"></a>00786 <span class="comment"></span><span class="keywordtype">void</span>
<a name="l00787"></a><a class="code" href="classlot.html#8318a661018ad43abe51e1033badd58f">00787</a> <a class="code" href="classlot.html#8318a661018ad43abe51e1033badd58f">lot::MT_R_initialize</a>(<span class="keywordtype">int</span> seed) {
<a name="l00788"></a>00788   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 50; ++j) {
<a name="l00789"></a>00789     seed = (69069*seed + 1);
<a name="l00790"></a>00790   }
<a name="l00791"></a>00791   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; MT_N; ++j) {
<a name="l00792"></a>00792     seed = (69069*seed + 1);
<a name="l00793"></a>00793     mt[j] = seed;
<a name="l00794"></a>00794   }
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 <span class="comment"></span>
<a name="l00797"></a>00797 <span class="comment">/// generate random integer on [0,0xffffffff]-interval</span>
<a name="l00798"></a>00798 <span class="comment">///</span>
<a name="l00799"></a>00799 <span class="comment"></span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
<a name="l00800"></a><a class="code" href="classlot.html#807ce1ec502dc36bd843488d313c81c2">00800</a> <a class="code" href="classlot.html#807ce1ec502dc36bd843488d313c81c2">lot::MT_genrand_int</a>(<span class="keywordtype">void</span>) {
<a name="l00801"></a>00801     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> y;
<a name="l00802"></a>00802     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mag01[2]={0x0, MATRIX_A};
<a name="l00803"></a>00803     <span class="comment">/* mag01[x] = x * MATRIX_A  for x=0,1 */</span>
<a name="l00804"></a>00804 
<a name="l00805"></a>00805     <span class="keywordflow">if</span> (mti &gt;= MT_N) { <span class="comment">/* generate MT_N words at one time */</span>
<a name="l00806"></a>00806       <span class="keywordtype">int</span> kk;
<a name="l00807"></a>00807       
<a name="l00808"></a>00808       <span class="keywordflow">if</span> (mti == MT_N+1)   <span class="comment">/* if sgenrand() has not been called, */</span>
<a name="l00809"></a>00809         <a class="code" href="classlot.html#726a24cd6215f27a396c1ee699e0b1a9">MT_sgenrand</a>(5489UL); <span class="comment">/* a default initial seed is used   */</span>
<a name="l00810"></a>00810 
<a name="l00811"></a>00811       <span class="keywordflow">for</span> (kk = 0; kk &lt; MT_N - MT_M; kk++) {
<a name="l00812"></a>00812         y = (mt[kk] &amp; UPPER_MASK) | (mt[kk+1] &amp; LOWER_MASK);
<a name="l00813"></a>00813         mt[kk] = mt[kk+MT_M] ^ (y &gt;&gt; 1) ^ mag01[y &amp; 0x1UL];
<a name="l00814"></a>00814       }
<a name="l00815"></a>00815       <span class="keywordflow">for</span> (; kk &lt; MT_N - 1; kk++) {
<a name="l00816"></a>00816         y = (mt[kk] &amp; UPPER_MASK) | (mt[kk+1] &amp; LOWER_MASK);
<a name="l00817"></a>00817         mt[kk] = mt[kk+(MT_M-MT_N)] ^ (y &gt;&gt; 1) ^ mag01[y &amp; 0x1UL];
<a name="l00818"></a>00818       }
<a name="l00819"></a>00819       y = (mt[MT_N-1] &amp; UPPER_MASK) | (mt[0] &amp; LOWER_MASK);
<a name="l00820"></a>00820       mt[MT_N-1] = mt[MT_M-1] ^ (y &gt;&gt; 1) ^ mag01[y &amp; 0x1UL];
<a name="l00821"></a>00821       
<a name="l00822"></a>00822       mti = 0;
<a name="l00823"></a>00823     }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825     y = mt[mti++];
<a name="l00826"></a>00826 
<a name="l00827"></a>00827     <span class="comment">/* Tempering */</span>
<a name="l00828"></a>00828     y ^= (y &gt;&gt; 11);
<a name="l00829"></a>00829     y ^= (y &lt;&lt; 7) &amp; 0x9d2c5680UL;
<a name="l00830"></a>00830     y ^= (y &lt;&lt; 15) &amp; 0xefc60000UL;
<a name="l00831"></a>00831     y ^= (y &gt;&gt; 18);
<a name="l00832"></a>00832 
<a name="l00833"></a>00833     <span class="keywordflow">return</span> y;
<a name="l00834"></a>00834 }
<a name="l00835"></a>00835 <span class="comment"></span>
<a name="l00836"></a>00836 <span class="comment">/// generate random double uniform on (0,1)</span>
<a name="l00837"></a>00837 <span class="comment">///</span>
<a name="l00838"></a>00838 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l00839"></a><a class="code" href="classlot.html#17369070dd445895b6cefc1f7c41e7a3">00839</a> <a class="code" href="classlot.html#17369070dd445895b6cefc1f7c41e7a3">lot::MT_genrand</a>(<span class="keywordtype">void</span>) {
<a name="l00840"></a>00840   <span class="keywordflow">return</span> (static_cast&lt;double&gt;(<a class="code" href="classlot.html#807ce1ec502dc36bd843488d313c81c2">MT_genrand_int</a>()) + 0.5)*(1.0/4294967296.0);
<a name="l00841"></a>00841 }
<a name="l00842"></a>00842 <span class="comment"></span>
<a name="l00843"></a>00843 <span class="comment">/// generate random double uniform on [0,1)</span>
<a name="l00844"></a>00844 <span class="comment">///</span>
<a name="l00845"></a>00845 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l00846"></a><a class="code" href="classlot.html#009c1e57a4716153b28734b279e67f82">00846</a> <a class="code" href="classlot.html#009c1e57a4716153b28734b279e67f82">lot::MT_genrand_with_zero</a>(<span class="keywordtype">void</span>) {
<a name="l00847"></a>00847   <span class="keywordflow">return</span> <a class="code" href="classlot.html#807ce1ec502dc36bd843488d313c81c2">MT_genrand_int</a>()*(1.0/4294967296.0); 
<a name="l00848"></a>00848 }
<a name="l00849"></a>00849 <span class="comment"></span>
<a name="l00850"></a>00850 <span class="comment">/// generate random double uniform on [0,1]</span>
<a name="l00851"></a>00851 <span class="comment">///</span>
<a name="l00852"></a>00852 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l00853"></a><a class="code" href="classlot.html#e39c9e6233d2865f0b51db08a0ab8515">00853</a> <a class="code" href="classlot.html#e39c9e6233d2865f0b51db08a0ab8515">lot::MT_genrand_with_zero_one</a>(<span class="keywordtype">void</span>) {
<a name="l00854"></a>00854   <span class="keywordflow">return</span> <a class="code" href="classlot.html#807ce1ec502dc36bd843488d313c81c2">MT_genrand_int</a>()*(1.0/4294967295.0); 
<a name="l00855"></a>00855 }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 <span class="comment"></span>
<a name="l00858"></a>00858 <span class="comment">/// Returns a random long in [0,maxval-1] </span>
<a name="l00859"></a>00859 <span class="comment">///</span>
<a name="l00860"></a>00860 <span class="comment">/// \param maxval </span>
<a name="l00861"></a>00861 <span class="comment">///</span>
<a name="l00862"></a>00862 <span class="comment"></span><span class="keywordtype">long</span>
<a name="l00863"></a><a class="code" href="classlot.html#9119710ef822516148964533171f2bed">00863</a> <a class="code" href="classlot.html#9119710ef822516148964533171f2bed">lot::random_long</a> (<span class="keywordtype">long</span> maxval) {
<a name="l00864"></a>00864   <span class="keywordtype">long</span> return_val = maxval;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   <span class="keywordflow">while</span> (return_val == maxval) {
<a name="l00867"></a>00867     return_val = static_cast&lt;long&gt;(floor((maxval * <a class="code" href="classlot.html#fb4e34587dc2deca4df5074968385c73">uniform</a>())));
<a name="l00868"></a>00868   }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870   <span class="keywordflow">return</span> return_val;
<a name="l00871"></a>00871 }
<a name="l00872"></a>00872 <span class="comment"></span>
<a name="l00873"></a>00873 <span class="comment">/// Returns a random int in [0,maxval-1] </span>
<a name="l00874"></a>00874 <span class="comment">///</span>
<a name="l00875"></a>00875 <span class="comment">/// \param maxval </span>
<a name="l00876"></a>00876 <span class="comment">///</span>
<a name="l00877"></a>00877 <span class="comment"></span><span class="keywordtype">int</span>
<a name="l00878"></a><a class="code" href="classlot.html#5a7b4eb4a7f39f306696d4e24ef603de">00878</a> <a class="code" href="classlot.html#5a7b4eb4a7f39f306696d4e24ef603de">lot::random_int</a> (<span class="keywordtype">int</span> maxval) {
<a name="l00879"></a>00879   <span class="keywordtype">int</span> return_val = maxval;
<a name="l00880"></a>00880 
<a name="l00881"></a>00881   <span class="keywordflow">while</span> (return_val == maxval) {
<a name="l00882"></a>00882     <span class="keywordtype">double</span> r = <a class="code" href="classlot.html#fb4e34587dc2deca4df5074968385c73">uniform</a>();
<a name="l00883"></a>00883     return_val = static_cast&lt;int&gt;(floor(maxval * r));
<a name="l00884"></a>00884   }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   <span class="keywordflow">return</span> return_val;
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="preprocessor">#ifdef M_LN2</span>
<a name="l00890"></a>00890 <span class="preprocessor"></span><span class="preprocessor">#define expmax (DBL_MAX_EXP * M_LN2)</span><span class="comment">/* = log(DBL_MAX) */</span>
<a name="l00891"></a>00891 <span class="preprocessor">#else</span>
<a name="l00892"></a><a class="code" href="lot_8cpp.html#092e2728a7854492e853e7ff11122f1e">00892</a> <span class="preprocessor"></span><span class="preprocessor">#define expmax  log(DBL_MAX)</span>
<a name="l00893"></a>00893 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00894"></a>00894 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00895"></a>00895 <span class="comment">/// Returns a random beta variate</span>
<a name="l00896"></a>00896 <span class="comment">///</span>
<a name="l00897"></a>00897 <span class="comment">/// \f[f(x) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}x^{a-1}(1-x)^{b-1} \f]</span>
<a name="l00898"></a>00898 <span class="comment">///</span>
<a name="l00899"></a>00899 <span class="comment">/// \param aa   The first beta parameter (\f$a\f$)</span>
<a name="l00900"></a>00900 <span class="comment">/// \param bb   The second beta parameter (\f$b\f$)</span>
<a name="l00901"></a>00901 <span class="comment">///</span>
<a name="l00902"></a>00902 <span class="comment">/// Returns a random variable from a beta distribution with parameters</span>
<a name="l00903"></a>00903 <span class="comment">/// aa and bb.</span>
<a name="l00904"></a>00904 <span class="comment">///</span>
<a name="l00905"></a>00905 <span class="comment">/// NOTE: Checks for aa, bb &gt; 0 not included</span>
<a name="l00906"></a>00906 <span class="comment">///</span>
<a name="l00907"></a>00907 <span class="comment">/// NOTE: R uses RNGs uniform on [0,1). To ensure consistency with that</span>
<a name="l00908"></a>00908 <span class="comment">/// well tested code make sure that you have Set_MT(ZERO), or the equivalent,</span>
<a name="l00909"></a>00909 <span class="comment">/// if you are using the Mersenne-Twister. ZERO is the default.</span>
<a name="l00910"></a>00910 <span class="comment">///</span>
<a name="l00911"></a>00911 <span class="comment">/// This implementation is derived from R v1.9.0</span>
<a name="l00912"></a>00912 <span class="comment">///</span>
<a name="l00913"></a>00913 <span class="comment"></span><span class="comment">//  R : A Computer Language for Statistical Data Analysis</span>
<a name="l00914"></a>00914 <span class="comment">//  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka</span>
<a name="l00915"></a>00915 <span class="comment">//  Copyright (C) 2000 The R Development Core Team</span>
<a name="l00916"></a>00916 <span class="comment">//</span>
<a name="l00917"></a>00917 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l00918"></a>00918 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l00919"></a>00919 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00920"></a>00920 <span class="comment">//  (at your option) any later version.</span>
<a name="l00921"></a>00921 <span class="comment">//</span>
<a name="l00922"></a>00922 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l00923"></a>00923 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00924"></a>00924 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00925"></a>00925 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l00926"></a>00926 <span class="comment">//</span>
<a name="l00927"></a>00927 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l00928"></a>00928 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l00929"></a>00929 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l00930"></a>00930 <span class="comment">//</span>
<a name="l00931"></a>00931 <span class="comment">// Reference:</span>
<a name="l00932"></a>00932 <span class="comment">// R. C. H. Cheng (1978).</span>
<a name="l00933"></a>00933 <span class="comment">// Generating beta variates with nonintegral shape parameters.</span>
<a name="l00934"></a>00934 <span class="comment">// Communications of the ACM 21, 317-322.</span>
<a name="l00935"></a>00935 <span class="comment">// (Algorithms BB and BC)</span>
<a name="l00936"></a>00936 <span class="comment">// </span>
<a name="l00937"></a>00937 <span class="keywordtype">double</span>
<a name="l00938"></a><a class="code" href="classlot.html#7bb4ea11b0b4379f75705f8c9a39dffa">00938</a> <a class="code" href="classlot.html#7bb4ea11b0b4379f75705f8c9a39dffa">lot::beta</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> aa, <span class="keyword">const</span> <span class="keywordtype">double</span> bb) {
<a name="l00939"></a>00939   <span class="keywordtype">double</span> a, b, alpha;
<a name="l00940"></a>00940   <span class="keywordtype">double</span> r, s, <a class="code" href="classlot.html#2c92917eba7874183e6f3672c9ac2f61">t</a>, u1, u2, v, w, y, z;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="keywordtype">int</span> qsame;
<a name="l00943"></a>00943   <span class="comment">/* FIXME:  Keep Globals (properly) for threading */</span>
<a name="l00944"></a>00944   <span class="comment">/* Uses these GLOBALS to save time when many rv's are generated : */</span>
<a name="l00945"></a>00945   <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="classlot.html#7bb4ea11b0b4379f75705f8c9a39dffa">beta</a>, <a class="code" href="classlot.html#7afffff162938dd57de9fe7f18267fd8">gamma</a>, delta, k1, k2;
<a name="l00946"></a>00946   <span class="keyword">static</span> <span class="keywordtype">double</span> olda = -1.0;
<a name="l00947"></a>00947   <span class="keyword">static</span> <span class="keywordtype">double</span> oldb = -1.0;
<a name="l00948"></a>00948   <span class="comment">/* Test if we need new "initializing" */</span>
<a name="l00949"></a>00949   qsame = (olda == aa) &amp;&amp; (oldb == bb);
<a name="l00950"></a>00950   <span class="keywordflow">if</span> (!qsame) {
<a name="l00951"></a>00951     olda = aa;
<a name="l00952"></a>00952     oldb = bb;
<a name="l00953"></a>00953   }
<a name="l00954"></a>00954   a = fmin2(aa, bb);
<a name="l00955"></a>00955   b = fmax2(aa, bb); <span class="comment">/* a &lt;= b */</span>
<a name="l00956"></a>00956   alpha = a + b;
<a name="l00957"></a>00957 <span class="preprocessor">#define v_w_from__u1_bet(AA)   \</span>
<a name="l00958"></a>00958 <span class="preprocessor">     v = beta * log(u1 / (1.0 - u1)); \</span>
<a name="l00959"></a>00959 <span class="preprocessor">     if (v &lt;= expmax)   \</span>
<a name="l00960"></a>00960 <span class="preprocessor">  w = AA * exp(v);  \</span>
<a name="l00961"></a>00961 <span class="preprocessor">     else    \</span>
<a name="l00962"></a>00962 <span class="preprocessor">  w = DBL_MAX</span>
<a name="l00963"></a>00963 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (a &lt;= 1.0) { <span class="comment">/* --- Algorithm BC --- */</span>
<a name="l00964"></a>00964     <span class="comment">/* changed notation, now also a &lt;= b (was reversed) */</span>
<a name="l00965"></a>00965     <span class="keywordflow">if</span> (!qsame) { <span class="comment">/* initialize */</span>
<a name="l00966"></a>00966       beta = 1.0 / a;
<a name="l00967"></a>00967       delta = 1.0 + b - a;
<a name="l00968"></a>00968       k1 = delta * (0.0138889 + 0.0416667 * a) / (b * beta - 0.777778);
<a name="l00969"></a>00969       k2 = 0.25 + (0.5 + 0.25 / delta) * a;
<a name="l00970"></a>00970     }
<a name="l00971"></a>00971     <span class="comment">/* FIXME: "do { } while()", but not trivially because of "continue"s:*/</span>
<a name="l00972"></a>00972     <span class="keywordflow">for</span> (;;) {
<a name="l00973"></a>00973       u1 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l00974"></a>00974       u2 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l00975"></a>00975       <span class="keywordflow">if</span> (u1 &lt; 0.5) {
<a name="l00976"></a>00976         y = u1 * u2;
<a name="l00977"></a>00977         z = u1 * y;
<a name="l00978"></a>00978         <span class="keywordflow">if</span> (0.25 * u2 + z - y &gt;= k1)
<a name="l00979"></a>00979           <span class="keywordflow">continue</span>;
<a name="l00980"></a>00980       } <span class="keywordflow">else</span> {
<a name="l00981"></a>00981         z = u1 * u1 * u2;
<a name="l00982"></a>00982         <span class="keywordflow">if</span> (z &lt;= 0.25) {
<a name="l00983"></a>00983           v_w_from__u1_bet(b);
<a name="l00984"></a>00984           <span class="keywordflow">break</span>;
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986         <span class="keywordflow">if</span> (z &gt;= k2)
<a name="l00987"></a>00987           <span class="keywordflow">continue</span>;
<a name="l00988"></a>00988       }
<a name="l00989"></a>00989       v_w_from__u1_bet(b);
<a name="l00990"></a>00990       <span class="keywordflow">if</span> (alpha * (log(alpha / (a + w)) + v) - 1.3862944 &gt;= log(z))
<a name="l00991"></a>00991         <span class="keywordflow">break</span>;
<a name="l00992"></a>00992     }
<a name="l00993"></a>00993     <span class="keywordflow">return</span> (aa == a) ? a / (a + w) : w / (a + w);
<a name="l00994"></a>00994   } <span class="keywordflow">else</span> {  <span class="comment">/* Algorithm BB */</span>
<a name="l00995"></a>00995     <span class="keywordflow">if</span> (!qsame) { <span class="comment">/* initialize */</span>
<a name="l00996"></a>00996       beta = sqrt((alpha - 2.0) / (2.0 * a * b - alpha));
<a name="l00997"></a>00997       gamma = a + 1.0 / beta;
<a name="l00998"></a>00998     }
<a name="l00999"></a>00999     <span class="keywordflow">do</span> {
<a name="l01000"></a>01000       u1 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l01001"></a>01001       u2 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l01002"></a>01002       v_w_from__u1_bet(a);
<a name="l01003"></a>01003       z = u1 * u1 * u2;
<a name="l01004"></a>01004       r = gamma * v - 1.3862944;
<a name="l01005"></a>01005       s = a + r - w;
<a name="l01006"></a>01006       <span class="keywordflow">if</span> (s + 2.609438 &gt;= 5.0 * z)
<a name="l01007"></a>01007         <span class="keywordflow">break</span>;
<a name="l01008"></a>01008       t = log(z);
<a name="l01009"></a>01009       <span class="keywordflow">if</span> (s &gt; t)
<a name="l01010"></a>01010         <span class="keywordflow">break</span>;
<a name="l01011"></a>01011     } <span class="keywordflow">while</span> (r + alpha * log(alpha / (b + w)) &lt; t);
<a name="l01012"></a>01012     <span class="keywordflow">return</span> (aa != a) ? b / (b + w) : w / (b + w);
<a name="l01013"></a>01013   }
<a name="l01014"></a>01014 }
<a name="l01015"></a>01015 <span class="comment"></span>
<a name="l01016"></a>01016 <span class="comment">/// Returns a random binomial variate</span>
<a name="l01017"></a>01017 <span class="comment">///</span>
<a name="l01018"></a>01018 <span class="comment">/// \f[ f(x) = {n \choose k}p^k(1-p)^{n-k} \f]</span>
<a name="l01019"></a>01019 <span class="comment">///</span>
<a name="l01020"></a>01020 <span class="comment">/// \param nin  sample size (\f$n\f$)</span>
<a name="l01021"></a>01021 <span class="comment">/// \param pp   probability of success on each trial (\f$p\f$)</span>
<a name="l01022"></a>01022 <span class="comment">///</span>
<a name="l01023"></a>01023 <span class="comment">/// \f[ \mbox{E}(x) = np \f]</span>
<a name="l01024"></a>01024 <span class="comment">/// \f[ \mbox{Var}(x) = np(1-p) \f]</span>
<a name="l01025"></a>01025 <span class="comment">///</span>
<a name="l01026"></a>01026 <span class="comment">/// This implementation is derived from R v1.9.0.</span>
<a name="l01027"></a>01027 <span class="comment">///</span>
<a name="l01028"></a>01028 <span class="comment">/// NOTE: Checks for finite nin and pp not included. </span>
<a name="l01029"></a>01029 <span class="comment">///       Check for nin == floor(n+0.5) not included</span>
<a name="l01030"></a>01030 <span class="comment">///</span>
<a name="l01031"></a>01031 <span class="comment"></span><span class="comment">// NOTE: R uses RNGs uniform on [0,1). To ensure consistency with that</span>
<a name="l01032"></a>01032 <span class="comment">// well tested code make sure that you have Set_MT(ZERO), or the equivalent,</span>
<a name="l01033"></a>01033 <span class="comment">// if you are using the Mersenne-Twister. ZERO is the default.</span>
<a name="l01034"></a>01034 <span class="comment">//</span>
<a name="l01035"></a>01035 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l01036"></a>01036 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l01037"></a>01037 <span class="comment">//  Copyright (C) 2000 The R Development Core Team</span>
<a name="l01038"></a>01038 <span class="comment">//</span>
<a name="l01039"></a>01039 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l01040"></a>01040 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l01041"></a>01041 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l01042"></a>01042 <span class="comment">//  (at your option) any later version.</span>
<a name="l01043"></a>01043 <span class="comment">//</span>
<a name="l01044"></a>01044 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l01045"></a>01045 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l01046"></a>01046 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l01047"></a>01047 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l01048"></a>01048 <span class="comment">//</span>
<a name="l01049"></a>01049 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l01050"></a>01050 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l01051"></a>01051 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l01052"></a>01052 <span class="comment">//</span>
<a name="l01053"></a>01053 <span class="comment">//  SYNOPSIS</span>
<a name="l01054"></a>01054 <span class="comment">//</span>
<a name="l01055"></a>01055 <span class="comment">// #include "Rmath.h"</span>
<a name="l01056"></a>01056 <span class="comment">// double rbinom(double nin, double pp)</span>
<a name="l01057"></a>01057 <span class="comment">//</span>
<a name="l01058"></a>01058 <span class="comment">//  DESCRIPTION</span>
<a name="l01059"></a>01059 <span class="comment">//</span>
<a name="l01060"></a>01060 <span class="comment">// Random variates from the binomial distribution.</span>
<a name="l01061"></a>01061 <span class="comment">//</span>
<a name="l01062"></a>01062 <span class="comment">//  REFERENCE</span>
<a name="l01063"></a>01063 <span class="comment">//</span>
<a name="l01064"></a>01064 <span class="comment">// Kachitvichyanukul, V. and Schmeiser, B. W. (1988).</span>
<a name="l01065"></a>01065 <span class="comment">// Binomial random variate generation.</span>
<a name="l01066"></a>01066 <span class="comment">// Communications of the ACM 31, p216.</span>
<a name="l01067"></a>01067 <span class="comment">// (Algorithm BTPEC).</span>
<a name="l01068"></a>01068 <span class="comment">// </span>
<a name="l01069"></a>01069 <span class="keywordtype">int</span>
<a name="l01070"></a><a class="code" href="classlot.html#dc497ec291a4f5aa0fc327e7e97758be">01070</a> <a class="code" href="classlot.html#dc497ec291a4f5aa0fc327e7e97758be">lot::binom</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> nin, <span class="keyword">const</span> <span class="keywordtype">double</span> pp) {
<a name="l01071"></a>01071   <span class="keyword">static</span> <span class="keywordtype">double</span> c, fm, npq, p1, p2, p3, p4, qn;
<a name="l01072"></a>01072   <span class="keyword">static</span> <span class="keywordtype">double</span> xl, xll, xlr, xm, xr;
<a name="l01073"></a>01073   <span class="keyword">static</span> <span class="keywordtype">double</span> psave = -1.0;
<a name="l01074"></a>01074   <span class="keyword">static</span> <span class="keywordtype">int</span> nsave = -1;
<a name="l01075"></a>01075   <span class="keyword">static</span> <span class="keywordtype">int</span> m;
<a name="l01076"></a>01076   <span class="keywordtype">double</span> <a class="code" href="classlot.html#74885f27b6d8afcc1e7c202f7644fbfc">f</a>, f1, f2, u, v, w, w2, x, x1, x2, z, z2;
<a name="l01077"></a>01077   <span class="keywordtype">double</span> p, q, np, g, r, al, alv, amaxp, ffm, ynorm;
<a name="l01078"></a>01078   <span class="keywordtype">int</span> i,ix,k, n;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080   n = static_cast&lt;int&gt;(floor(nin + 0.5));
<a name="l01081"></a>01081   <span class="keywordflow">if</span> (n == 0 || pp == 0.) <span class="keywordflow">return</span> 0;
<a name="l01082"></a>01082   <span class="keywordflow">if</span> (pp == 1.) <span class="keywordflow">return</span> n;
<a name="l01083"></a>01083   p = fmin2(pp, 1. - pp);
<a name="l01084"></a>01084   q = 1. - p;
<a name="l01085"></a>01085   np = n * p;
<a name="l01086"></a>01086   r = p / q;
<a name="l01087"></a>01087   g = r * (n + 1);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089   <span class="comment">/* Setup, perform only when parameters change [using static (globals): */</span>
<a name="l01090"></a>01090   <span class="comment">/* FIXING: Want this thread safe</span>
<a name="l01091"></a>01091 <span class="comment">     -- use as little (thread globals) as possible</span>
<a name="l01092"></a>01092 <span class="comment">  */</span>
<a name="l01093"></a>01093   <span class="keywordflow">if</span> (pp != psave || n != nsave) {
<a name="l01094"></a>01094     psave = pp;
<a name="l01095"></a>01095     nsave = n;
<a name="l01096"></a>01096     <span class="keywordflow">if</span> (np &lt; 30.0) {
<a name="l01097"></a>01097             <span class="comment">/* inverse cdf logic for mean less than 30 */</span>
<a name="l01098"></a>01098             qn = pow(q, static_cast&lt;double&gt;(n));
<a name="l01099"></a>01099             <span class="keywordflow">goto</span> L_np_small;
<a name="l01100"></a>01100     } <span class="keywordflow">else</span> {
<a name="l01101"></a>01101             ffm = np + p;
<a name="l01102"></a>01102             m = static_cast&lt;int&gt;(ffm);
<a name="l01103"></a>01103             fm = m;
<a name="l01104"></a>01104             npq = np * q;
<a name="l01105"></a>01105             p1 = static_cast&lt;int&gt;(2.195 * sqrt(npq) - 4.6 * q) + 0.5;
<a name="l01106"></a>01106             xm = fm + 0.5;
<a name="l01107"></a>01107             xl = xm - p1;
<a name="l01108"></a>01108             xr = xm + p1;
<a name="l01109"></a>01109             c = 0.134 + 20.5 / (15.3 + fm);
<a name="l01110"></a>01110             al = (ffm - xl) / (ffm - xl * p);
<a name="l01111"></a>01111             xll = al * (1.0 + 0.5 * al);
<a name="l01112"></a>01112             al = (xr - ffm) / (xr * q);
<a name="l01113"></a>01113             xlr = al * (1.0 + 0.5 * al);
<a name="l01114"></a>01114             p2 = p1 * (1.0 + c + c);
<a name="l01115"></a>01115             p3 = p2 + c / xll;
<a name="l01116"></a>01116             p4 = p3 + c / xlr;
<a name="l01117"></a>01117     }
<a name="l01118"></a>01118   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n == nsave) {
<a name="l01119"></a>01119     <span class="keywordflow">if</span> (np &lt; 30.0)
<a name="l01120"></a>01120             <span class="keywordflow">goto</span> L_np_small;
<a name="l01121"></a>01121   }
<a name="l01122"></a>01122   <span class="comment">/*-------------------------- np = n*p &gt;= 30 : ------------------- */</span>
<a name="l01123"></a>01123   <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l01124"></a>01124     u = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>() * p4;
<a name="l01125"></a>01125     v = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l01126"></a>01126     <span class="comment">/* triangular region */</span>
<a name="l01127"></a>01127     <span class="keywordflow">if</span> (u &lt;= p1) {
<a name="l01128"></a>01128       ix = static_cast&lt;int&gt;(xm - p1 * v + u);
<a name="l01129"></a>01129       <span class="keywordflow">goto</span> finis;
<a name="l01130"></a>01130     }
<a name="l01131"></a>01131     <span class="comment">/* parallelogram region */</span>
<a name="l01132"></a>01132     <span class="keywordflow">if</span> (u &lt;= p2) {
<a name="l01133"></a>01133       x = xl + (u - p1) / c;
<a name="l01134"></a>01134       v = v * c + 1.0 - fabs(xm - x) / p1;
<a name="l01135"></a>01135       <span class="keywordflow">if</span> (v &gt; 1.0 || v &lt;= 0.)
<a name="l01136"></a>01136               <span class="keywordflow">continue</span>;
<a name="l01137"></a>01137       ix = static_cast&lt;int&gt;(x);
<a name="l01138"></a>01138     } <span class="keywordflow">else</span> {
<a name="l01139"></a>01139       <span class="keywordflow">if</span> (u &gt; p3) {     <span class="comment">/* right tail */</span>
<a name="l01140"></a>01140               ix = static_cast&lt;int&gt;(xr - log(v) / xlr);
<a name="l01141"></a>01141               <span class="keywordflow">if</span> (ix &gt; n)
<a name="l01142"></a>01142           <span class="keywordflow">continue</span>;
<a name="l01143"></a>01143               v = v * (u - p3) * xlr;
<a name="l01144"></a>01144       } <span class="keywordflow">else</span> {<span class="comment">/* left tail */</span>
<a name="l01145"></a>01145               ix = static_cast&lt;int&gt;(xl + log(v) / xll);
<a name="l01146"></a>01146               <span class="keywordflow">if</span> (ix &lt; 0)
<a name="l01147"></a>01147           <span class="keywordflow">continue</span>;
<a name="l01148"></a>01148               v = v * (u - p2) * xll;
<a name="l01149"></a>01149       }
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151     <span class="comment">/* determine appropriate way to perform accept/reject test */</span>
<a name="l01152"></a>01152     k = abs(ix - m);
<a name="l01153"></a>01153     <span class="keywordflow">if</span> (k &lt;= 20 || k &gt;= npq / 2 - 1) {
<a name="l01154"></a>01154       <span class="comment">/* explicit evaluation */</span>
<a name="l01155"></a>01155       f = 1.0;
<a name="l01156"></a>01156       <span class="keywordflow">if</span> (m &lt; ix) {
<a name="l01157"></a>01157               <span class="keywordflow">for</span> (i = m + 1; i &lt;= ix; i++)
<a name="l01158"></a>01158           f *= (g / i - r);
<a name="l01159"></a>01159       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m != ix) {
<a name="l01160"></a>01160               <span class="keywordflow">for</span> (i = ix + 1; i &lt;= m; i++)
<a name="l01161"></a>01161           f /= (g / i - r);
<a name="l01162"></a>01162       }
<a name="l01163"></a>01163       <span class="keywordflow">if</span> (v &lt;= f)
<a name="l01164"></a>01164               <span class="keywordflow">goto</span> finis;
<a name="l01165"></a>01165     } <span class="keywordflow">else</span> {
<a name="l01166"></a>01166       <span class="comment">/* squeezing using upper and lower bounds on log(f(x)) */</span>
<a name="l01167"></a>01167       amaxp = (k / npq) * ((k * (k / 3. + 0.625) + 0.1666666666666) / npq + 0.5);
<a name="l01168"></a>01168       ynorm = -k * k / (2.0 * npq);
<a name="l01169"></a>01169       alv = log(v);
<a name="l01170"></a>01170       <span class="keywordflow">if</span> (alv &lt; ynorm - amaxp)
<a name="l01171"></a>01171               <span class="keywordflow">goto</span> finis;
<a name="l01172"></a>01172       <span class="keywordflow">if</span> (alv &lt;= ynorm + amaxp) {
<a name="l01173"></a>01173               <span class="comment">/* stirling's formula to machine accuracy */</span>
<a name="l01174"></a>01174               <span class="comment">/* for the final acceptance/rejection test */</span>
<a name="l01175"></a>01175               x1 = ix + 1;
<a name="l01176"></a>01176               f1 = fm + 1.0;
<a name="l01177"></a>01177               z = n + 1 - fm;
<a name="l01178"></a>01178               w = n - ix + 1.0;
<a name="l01179"></a>01179               z2 = z * z;
<a name="l01180"></a>01180               x2 = x1 * x1;
<a name="l01181"></a>01181               f2 = f1 * f1;
<a name="l01182"></a>01182               w2 = w * w;
<a name="l01183"></a>01183               <span class="keywordflow">if</span> (alv &lt;= xm * log(f1 / x1) + (n - m + 0.5) * log(z / w) + (ix - m) * log(w * p / (x1 * q)) + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / f2) / f2) / f2) / f2) / f1 / 166320.0 + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / z2) / z2) / z2) / z2) / z / 166320.0 + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / x2) / x2) / x2) / x2) / x1 / 166320.0 + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / w2) / w2) / w2) / w2) / w / 166320.)
<a name="l01184"></a>01184           <span class="keywordflow">goto</span> finis;
<a name="l01185"></a>01185       }
<a name="l01186"></a>01186     }
<a name="l01187"></a>01187   }
<a name="l01188"></a>01188  L_np_small:
<a name="l01189"></a>01189   <span class="comment">/*---------------------- np = n*p &lt; 30 : ------------------------- */</span>
<a name="l01190"></a>01190   <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l01191"></a>01191     ix = 0;
<a name="l01192"></a>01192     f = qn;
<a name="l01193"></a>01193     u = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l01194"></a>01194     <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l01195"></a>01195       <span class="keywordflow">if</span> (u &lt; f)
<a name="l01196"></a>01196         <span class="keywordflow">goto</span> finis;
<a name="l01197"></a>01197       <span class="keywordflow">if</span> (ix &gt; 110)
<a name="l01198"></a>01198         <span class="keywordflow">break</span>;
<a name="l01199"></a>01199       u -= f;
<a name="l01200"></a>01200       ix++;
<a name="l01201"></a>01201       f *= (g / ix - r);
<a name="l01202"></a>01202     }
<a name="l01203"></a>01203   }
<a name="l01204"></a>01204  finis:
<a name="l01205"></a>01205   <span class="keywordflow">if</span> (psave &gt; 0.5) {
<a name="l01206"></a>01206     ix = n - ix;
<a name="l01207"></a>01207   }
<a name="l01208"></a>01208   <span class="keywordflow">return</span> ix;
<a name="l01209"></a>01209 }
<a name="l01210"></a>01210 <span class="comment"></span>
<a name="l01211"></a>01211 <span class="comment">/// Returns a Cauchy variate</span>
<a name="l01212"></a>01212 <span class="comment">///</span>
<a name="l01213"></a>01213 <span class="comment">/// \f[ f(x) = \frac{1}{\pi\mbox{s} (1 + (\frac{x-\mbox{l}}{\mbox{s}})^2)} \f]</span>
<a name="l01214"></a>01214 <span class="comment">///</span>
<a name="l01215"></a>01215 <span class="comment">/// \param l         the location parameter</span>
<a name="l01216"></a>01216 <span class="comment">/// \param s     the scale parameter</span>
<a name="l01217"></a>01217 <span class="comment">///</span>
<a name="l01218"></a>01218 <span class="comment">/// The expectation and variance of the Cauchy distribution are infinite.</span>
<a name="l01219"></a>01219 <span class="comment">/// The mode is equal to the location parameter.</span>
<a name="l01220"></a>01220 <span class="comment">///</span>
<a name="l01221"></a>01221 <span class="comment">/// Modified from R v2.0. Does not check isnan() on arguments. Does not</span>
<a name="l01222"></a>01222 <span class="comment">/// check that arguments are finite</span>
<a name="l01223"></a>01223 <span class="comment"></span><span class="comment">//</span>
<a name="l01224"></a>01224 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l01225"></a>01225 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l01226"></a>01226 <span class="comment">//  Copyright (C) 2000 The R Development Core Team</span>
<a name="l01227"></a>01227 <span class="comment">//</span>
<a name="l01228"></a>01228 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l01229"></a>01229 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l01230"></a>01230 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l01231"></a>01231 <span class="comment">//  (at your option) any later version.</span>
<a name="l01232"></a>01232 <span class="comment">//</span>
<a name="l01233"></a>01233 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l01234"></a>01234 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l01235"></a>01235 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l01236"></a>01236 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l01237"></a>01237 <span class="comment">//</span>
<a name="l01238"></a>01238 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l01239"></a>01239 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l01240"></a>01240 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l01241"></a>01241 <span class="comment">//</span>
<a name="l01242"></a>01242 <span class="comment">//  SYNOPSIS</span>
<a name="l01243"></a>01243 <span class="comment">//</span>
<a name="l01244"></a>01244 <span class="comment">//    #include &lt;Rmath.h&gt;</span>
<a name="l01245"></a>01245 <span class="comment">//    double rcauchy(double location, double scale);</span>
<a name="l01246"></a>01246 <span class="comment">//</span>
<a name="l01247"></a>01247 <span class="comment">//  DESCRIPTION</span>
<a name="l01248"></a>01248 <span class="comment">//</span>
<a name="l01249"></a>01249 <span class="comment">//    Random variates from the Cauchy distribution.</span>
<a name="l01250"></a>01250 <span class="comment">//</span>
<a name="l01251"></a>01251 <span class="keywordtype">double</span> 
<a name="l01252"></a><a class="code" href="classlot.html#fde6a43fdff4f09dfb9dc6546d02cc9a">01252</a> <a class="code" href="classlot.html#fde6a43fdff4f09dfb9dc6546d02cc9a">lot::cauchy</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> l, <span class="keyword">const</span> <span class="keywordtype">double</span> s) {
<a name="l01253"></a>01253   <span class="keywordflow">return</span> l + s * tan(M_PI * <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>());
<a name="l01254"></a>01254 }
<a name="l01255"></a>01255 <span class="comment"></span>
<a name="l01256"></a>01256 <span class="comment">/// Returns a chi-squared variate</span>
<a name="l01257"></a>01257 <span class="comment">///</span>
<a name="l01258"></a>01258 <span class="comment">/// \f[ f(x) = \frac{1}{2^{n/2}\Gamma(n/2)}x^{n/2-1}e^{-x/2} \f]</span>
<a name="l01259"></a>01259 <span class="comment">///</span>
<a name="l01260"></a>01260 <span class="comment">/// \param n         degrees of freedom for the chi-squared density</span>
<a name="l01261"></a>01261 <span class="comment">///</span>
<a name="l01262"></a>01262 <span class="comment">/// \f[ \mbox{E}(x) = \mbox{n} \f]</span>
<a name="l01263"></a>01263 <span class="comment">/// \f[ \mbox{Var}(x) = 2\mbox{n} \f]</span>
<a name="l01264"></a>01264 <span class="comment">///</span>
<a name="l01265"></a>01265 <span class="comment">/// Derived from R v2.0. Does not check isfinite() on argument.</span>
<a name="l01266"></a>01266 <span class="comment"></span><span class="comment">//</span>
<a name="l01267"></a>01267 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l01268"></a>01268 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l01269"></a>01269 <span class="comment">//  Copyright (C) 2000 The R Development Core Team</span>
<a name="l01270"></a>01270 <span class="comment">//</span>
<a name="l01271"></a>01271 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l01272"></a>01272 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l01273"></a>01273 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l01274"></a>01274 <span class="comment">//  (at your option) any later version.</span>
<a name="l01275"></a>01275 <span class="comment">//</span>
<a name="l01276"></a>01276 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l01277"></a>01277 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l01278"></a>01278 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l01279"></a>01279 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l01280"></a>01280 <span class="comment">//</span>
<a name="l01281"></a>01281 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l01282"></a>01282 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l01283"></a>01283 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l01284"></a>01284 <span class="comment">//</span>
<a name="l01285"></a>01285 <span class="comment">//  SYNOPSIS</span>
<a name="l01286"></a>01286 <span class="comment">//</span>
<a name="l01287"></a>01287 <span class="comment">//    #include &lt;Rmath.h&gt;</span>
<a name="l01288"></a>01288 <span class="comment">//    double rchisq(double df);</span>
<a name="l01289"></a>01289 <span class="comment">//</span>
<a name="l01290"></a>01290 <span class="comment">//  DESCRIPTION</span>
<a name="l01291"></a>01291 <span class="comment">//</span>
<a name="l01292"></a>01292 <span class="comment">//    Random variates from the chi-squared distribution.</span>
<a name="l01293"></a>01293 <span class="comment">//</span>
<a name="l01294"></a>01294 <span class="comment">//  NOTES</span>
<a name="l01295"></a>01295 <span class="comment">//</span>
<a name="l01296"></a>01296 <span class="comment">//    Calls rgamma to do the real work.</span>
<a name="l01297"></a>01297 <span class="keywordtype">double</span> 
<a name="l01298"></a><a class="code" href="classlot.html#4d9467088ac8bbbae410107575405306">01298</a> <a class="code" href="classlot.html#4d9467088ac8bbbae410107575405306">lot::chisq</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> n) {
<a name="l01299"></a>01299     <span class="keywordflow">return</span> <a class="code" href="classlot.html#7afffff162938dd57de9fe7f18267fd8">gamma</a>(n / 2.0, 2.0);
<a name="l01300"></a>01300 }
<a name="l01301"></a>01301 
<a name="l01302"></a>01302 <span class="comment"></span>
<a name="l01303"></a>01303 <span class="comment">/// Returns a vector of Dirichlet variates</span>
<a name="l01304"></a>01304 <span class="comment">///</span>
<a name="l01305"></a>01305 <span class="comment">/// \f[ f({\bf x}) = \frac{\Gamma(\sum_i x_i)}{\prod_i\Gamma(x_i)}\prod_ix_i^{c_i} \f]</span>
<a name="l01306"></a>01306 <span class="comment">///</span>
<a name="l01307"></a>01307 <span class="comment">/// \param c [vector&lt;double&gt;] parameters of the Dirichlet</span>
<a name="l01308"></a>01308 <span class="comment">///</span>
<a name="l01309"></a>01309 <span class="comment"></span>std::vector&lt;double&gt;
<a name="l01310"></a><a class="code" href="classlot.html#5487d1b837af6bbb62097f8f096bd76c">01310</a> <a class="code" href="classlot.html#5487d1b837af6bbb62097f8f096bd76c">lot::dirichlet</a>(std::vector&lt;double&gt; c) {
<a name="l01311"></a>01311   <span class="keywordtype">int</span> n = c.size();
<a name="l01312"></a>01312   vector&lt;double&gt; p(n);
<a name="l01313"></a>01313   <span class="keywordflow">for</span> (;;) {
<a name="l01314"></a>01314     <a class="code" href="lot_8h.html#3559231b71cff6262be766dcc25d27a3">DblVect</a> g(n);
<a name="l01315"></a>01315     <span class="keywordtype">double</span> sum = 0.0;
<a name="l01316"></a>01316     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {
<a name="l01317"></a>01317       <span class="keywordtype">double</span> gammadev = <a class="code" href="classlot.html#7afffff162938dd57de9fe7f18267fd8">gamma</a>(c[i]);
<a name="l01318"></a>01318       g[i] = gammadev;
<a name="l01319"></a>01319       sum += gammadev;
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321     <span class="keywordtype">bool</span> ok = <span class="keyword">true</span>;
<a name="l01322"></a>01322     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {
<a name="l01323"></a>01323       p[i] = g[i] / sum;
<a name="l01324"></a>01324       <span class="comment">// if any of the p's are effectively zero,</span>
<a name="l01325"></a>01325       <span class="comment">// we must abort and try again</span>
<a name="l01326"></a>01326       <span class="keywordflow">if</span> (p[i] &lt; DBL_MIN) {
<a name="l01327"></a>01327         ok = <span class="keyword">false</span>;
<a name="l01328"></a>01328         <span class="keywordflow">break</span>;
<a name="l01329"></a>01329       }
<a name="l01330"></a>01330     }
<a name="l01331"></a>01331     <span class="keywordflow">if</span> (ok) {
<a name="l01332"></a>01332       <span class="keywordflow">break</span>;
<a name="l01333"></a>01333     }
<a name="l01334"></a>01334   }
<a name="l01335"></a>01335   <span class="keywordflow">return</span> p;
<a name="l01336"></a>01336 }
<a name="l01337"></a>01337 <span class="comment"></span>
<a name="l01338"></a>01338 <span class="comment">/// Returns a random value from an exponential distribution with mean 1.</span>
<a name="l01339"></a>01339 <span class="comment">///</span>
<a name="l01340"></a>01340 <span class="comment">/// \f[ f(x) = e^{-1} \f]</span>
<a name="l01341"></a>01341 <span class="comment">///</span>
<a name="l01342"></a>01342 <span class="comment">/// \f[ \mbox{E}(x) = 1 \f]</span>
<a name="l01343"></a>01343 <span class="comment">/// \f[ \mbox{Var}(x) = 1 \f]</span>
<a name="l01344"></a>01344 <span class="comment">///</span>
<a name="l01345"></a>01345 <span class="comment">/// originally derived from R v1.8.1</span>
<a name="l01346"></a>01346 <span class="comment">///</span>
<a name="l01347"></a>01347 <span class="comment">/// NOTE: R uses RNGs uniform on [0,1). To ensure consistency with that</span>
<a name="l01348"></a>01348 <span class="comment">/// well tested code make sure that you have Set_MT(ZERO), or the equivalent,</span>
<a name="l01349"></a>01349 <span class="comment">/// if you are using the Mersenne-Twister. ZERO is the default.</span>
<a name="l01350"></a>01350 <span class="comment">///</span>
<a name="l01351"></a>01351 <span class="comment"></span><span class="comment">// Mathlib : A C Library of Special Functions</span>
<a name="l01352"></a>01352 <span class="comment">// </span>
<a name="l01353"></a>01353 <span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<a name="l01354"></a>01354 <span class="comment">// it under the terms of the GNU General Public License as published by</span>
<a name="l01355"></a>01355 <span class="comment">// the Free Software Foundation; either version 2 of the License, or</span>
<a name="l01356"></a>01356 <span class="comment">// (at your option) any later version.</span>
<a name="l01357"></a>01357 <span class="comment">//</span>
<a name="l01358"></a>01358 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l01359"></a>01359 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l01360"></a>01360 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l01361"></a>01361 <span class="comment">// GNU General Public License for more details.</span>
<a name="l01362"></a>01362 <span class="comment">//</span>
<a name="l01363"></a>01363 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l01364"></a>01364 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l01365"></a>01365 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l01366"></a>01366 <span class="comment">//</span>
<a name="l01367"></a>01367 <span class="comment">// SYNOPSIS</span>
<a name="l01368"></a>01368 <span class="comment">//</span>
<a name="l01369"></a>01369 <span class="comment">//   #include &lt;Rmath.h&gt;</span>
<a name="l01370"></a>01370 <span class="comment">//   double exp_rand(void);</span>
<a name="l01371"></a>01371 <span class="comment">//</span>
<a name="l01372"></a>01372 <span class="comment">// DESCRIPTION</span>
<a name="l01373"></a>01373 <span class="comment">//</span>
<a name="l01374"></a>01374 <span class="comment">//   Random variates from the standard exponential distribution.</span>
<a name="l01375"></a>01375 <span class="comment">//</span>
<a name="l01376"></a>01376 <span class="comment">// REFERENCE</span>
<a name="l01377"></a>01377 <span class="comment">//</span>
<a name="l01378"></a>01378 <span class="comment">//   Ahrens, J.H. and Dieter, U. (1972).</span>
<a name="l01379"></a>01379 <span class="comment">//   Computer methods for sampling from the exponential and</span>
<a name="l01380"></a>01380 <span class="comment">//   normal distributions.</span>
<a name="l01381"></a>01381 <span class="comment">//   Comm. ACM, 15, 873-882.</span>
<a name="l01382"></a>01382 <span class="comment">//</span>
<a name="l01383"></a>01383 <span class="keywordtype">double</span>
<a name="l01384"></a><a class="code" href="classlot.html#ebd137003b2dd9a7b94c5988047e4774">01384</a> <a class="code" href="classlot.html#ebd137003b2dd9a7b94c5988047e4774">lot::expon</a>(<span class="keywordtype">void</span>) {
<a name="l01385"></a>01385   <span class="comment">/* q[k-1] = sum(log(2)^k / k!)  k=1,..,n, */</span>
<a name="l01386"></a>01386   <span class="comment">/* The highest n (here 8) is determined by q[n-1] = 1.0 */</span>
<a name="l01387"></a>01387   <span class="comment">/* within standard precision */</span>
<a name="l01388"></a>01388   <span class="keyword">const</span> <span class="keywordtype">double</span> q[] =
<a name="l01389"></a>01389     {
<a name="l01390"></a>01390       0.6931471805599453,
<a name="l01391"></a>01391       0.9333736875190459,
<a name="l01392"></a>01392       0.9888777961838675,
<a name="l01393"></a>01393       0.9984959252914960,
<a name="l01394"></a>01394       0.9998292811061389,
<a name="l01395"></a>01395       0.9999833164100727,
<a name="l01396"></a>01396       0.9999985691438767,
<a name="l01397"></a>01397       0.9999998906925558,
<a name="l01398"></a>01398       0.9999999924734159,
<a name="l01399"></a>01399       0.9999999995283275,
<a name="l01400"></a>01400       0.9999999999728814,
<a name="l01401"></a>01401       0.9999999999985598,
<a name="l01402"></a>01402       0.9999999999999289,
<a name="l01403"></a>01403       0.9999999999999968,
<a name="l01404"></a>01404       0.9999999999999999,
<a name="l01405"></a>01405       1.0000000000000000
<a name="l01406"></a>01406     };
<a name="l01407"></a>01407   <span class="keywordtype">double</span> a, u, ustar, umin;
<a name="l01408"></a>01408   <span class="keywordtype">int</span> i;
<a name="l01409"></a>01409   a = 0.;
<a name="l01410"></a>01410   <span class="comment">/* precaution if u = 0 is ever returned */</span>
<a name="l01411"></a>01411   u = <a class="code" href="classlot.html#fb4e34587dc2deca4df5074968385c73">uniform</a>();
<a name="l01412"></a>01412   <span class="keywordflow">while</span>(u &lt;= 0.0 || u &gt;= 1.0) u = <a class="code" href="classlot.html#fb4e34587dc2deca4df5074968385c73">uniform</a>();
<a name="l01413"></a>01413   <span class="keywordflow">for</span> (;;) {
<a name="l01414"></a>01414     u += u;
<a name="l01415"></a>01415     <span class="keywordflow">if</span> (u &gt; 1.0) {
<a name="l01416"></a>01416             <span class="keywordflow">break</span>;
<a name="l01417"></a>01417     }
<a name="l01418"></a>01418     a += q[0];
<a name="l01419"></a>01419   }
<a name="l01420"></a>01420   u -= 1.;
<a name="l01421"></a>01421   <span class="keywordflow">if</span> (u &lt;= q[0])
<a name="l01422"></a>01422     <span class="keywordflow">return</span> a + u;
<a name="l01423"></a>01423   i = 0;
<a name="l01424"></a>01424   ustar = <a class="code" href="classlot.html#fb4e34587dc2deca4df5074968385c73">uniform</a>();
<a name="l01425"></a>01425   umin = ustar;
<a name="l01426"></a>01426   <span class="keywordflow">do</span> {
<a name="l01427"></a>01427     ustar = <a class="code" href="classlot.html#fb4e34587dc2deca4df5074968385c73">uniform</a>();
<a name="l01428"></a>01428     <span class="keywordflow">if</span> (ustar &lt; umin) {
<a name="l01429"></a>01429             umin = ustar;
<a name="l01430"></a>01430     }
<a name="l01431"></a>01431     i++;
<a name="l01432"></a>01432   } <span class="keywordflow">while</span> (u &gt; q[i]);
<a name="l01433"></a>01433   <span class="keywordflow">return</span> a + umin * q[0];
<a name="l01434"></a>01434 }
<a name="l01435"></a>01435 <span class="comment"></span>
<a name="l01436"></a>01436 <span class="comment">/// Returns an F variate</span>
<a name="l01437"></a>01437 <span class="comment">///</span>
<a name="l01438"></a>01438 <span class="comment">/// \f[ f(x) = \frac{\Gamma((m+n)/2)}{\Gamma(m/2)\Gamma(n/2)}(m/n)^{m/2}x^{m/2-1}(1+(m/n)x)^{-(m+n)/2} \f]</span>
<a name="l01439"></a>01439 <span class="comment">///</span>
<a name="l01440"></a>01440 <span class="comment">/// \param m        ``numerator'' degrees of freedom</span>
<a name="l01441"></a>01441 <span class="comment">/// \param n        ``denominator'' degrees of freedom</span>
<a name="l01442"></a>01442 <span class="comment">///</span>
<a name="l01443"></a>01443 <span class="comment">/// \f[ \mbox{E}(x) = \frac{m}{m-2}, m &gt; 2 \f]</span>
<a name="l01444"></a>01444 <span class="comment">/// \f[ \mbox{Var}(x) = \frac{2m^2(n-2)}{n(m+2)}, n &gt; 2 \f]</span>
<a name="l01445"></a>01445 <span class="comment">///</span>
<a name="l01446"></a>01446 <span class="comment">/// Derived from R v2.0. Does not check arguments for isnan() or isfinite().</span>
<a name="l01447"></a>01447 <span class="comment"></span><span class="comment">//</span>
<a name="l01448"></a>01448 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l01449"></a>01449 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l01450"></a>01450 <span class="comment">//  Copyright (C) 2000 The R Development Core Team</span>
<a name="l01451"></a>01451 <span class="comment">//</span>
<a name="l01452"></a>01452 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l01453"></a>01453 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l01454"></a>01454 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l01455"></a>01455 <span class="comment">//  (at your option) any later version.</span>
<a name="l01456"></a>01456 <span class="comment">//</span>
<a name="l01457"></a>01457 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l01458"></a>01458 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l01459"></a>01459 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l01460"></a>01460 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l01461"></a>01461 <span class="comment">//</span>
<a name="l01462"></a>01462 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l01463"></a>01463 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l01464"></a>01464 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l01465"></a>01465 <span class="comment">//</span>
<a name="l01466"></a>01466 <span class="comment">//  SYNOPSIS</span>
<a name="l01467"></a>01467 <span class="comment">//</span>
<a name="l01468"></a>01468 <span class="comment">//    #include "mathlib.h"</span>
<a name="l01469"></a>01469 <span class="comment">//    double rf(double dfn, double dfd);</span>
<a name="l01470"></a>01470 <span class="comment">//</span>
<a name="l01471"></a>01471 <span class="comment">//  DESCRIPTION</span>
<a name="l01472"></a>01472 <span class="comment">//</span>
<a name="l01473"></a>01473 <span class="comment">//    Pseudo-random variates from an F distribution.</span>
<a name="l01474"></a>01474 <span class="comment">//</span>
<a name="l01475"></a>01475 <span class="comment">//  NOTES</span>
<a name="l01476"></a>01476 <span class="comment">//</span>
<a name="l01477"></a>01477 <span class="comment">//    This function calls rchisq to do the real work</span>
<a name="l01478"></a>01478 <span class="comment">//</span>
<a name="l01479"></a>01479 <span class="keywordtype">double</span>
<a name="l01480"></a><a class="code" href="classlot.html#74885f27b6d8afcc1e7c202f7644fbfc">01480</a> <a class="code" href="classlot.html#74885f27b6d8afcc1e7c202f7644fbfc">lot::f</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> m, <span class="keyword">const</span> <span class="keywordtype">double</span> n) {
<a name="l01481"></a>01481     <span class="keywordtype">double</span> v1, v2;
<a name="l01482"></a>01482     v1 = <a class="code" href="classlot.html#4d9467088ac8bbbae410107575405306">chisq</a>(m)/m;
<a name="l01483"></a>01483     v2 = <a class="code" href="classlot.html#4d9467088ac8bbbae410107575405306">chisq</a>(n)/n;
<a name="l01484"></a>01484     <span class="keywordflow">return</span> v1/v2;
<a name="l01485"></a>01485 }
<a name="l01486"></a>01486 <span class="comment"></span>
<a name="l01487"></a>01487 <span class="comment">/// Gamma random deviate</span>
<a name="l01488"></a>01488 <span class="comment">///</span>
<a name="l01489"></a>01489 <span class="comment">/// \param a       Shape</span>
<a name="l01490"></a>01490 <span class="comment">/// \param scale   Scale (\f$\sigma\f$, defaults to 1.0)</span>
<a name="l01491"></a>01491 <span class="comment">///</span>
<a name="l01492"></a>01492 <span class="comment">/// \f[ f(x) = \frac{1}{\sigma^a \Gamma(a)}x^{a-1}e^{-x/\sigma} \f]</span>
<a name="l01493"></a>01493 <span class="comment">///</span>
<a name="l01494"></a>01494 <span class="comment">/// \f[ \mu = a\sigma \f]</span>
<a name="l01495"></a>01495 <span class="comment">/// \f[ \sigma^2 = a\sigma^2 \f]</span>
<a name="l01496"></a>01496 <span class="comment">///</span>
<a name="l01497"></a>01497 <span class="comment">/// NOTE: Checks for finite scale and shape parameters not included</span>
<a name="l01498"></a>01498 <span class="comment">///</span>
<a name="l01499"></a>01499 <span class="comment">/// NOTE: R uses RNGs uniform on [0,1). To ensure consistency with that</span>
<a name="l01500"></a>01500 <span class="comment">/// well tested code make sure that you have Set_MT(ZERO), or the equivalent,</span>
<a name="l01501"></a>01501 <span class="comment">/// if you are using the Mersenne-Twister. ZERO is the default.</span>
<a name="l01502"></a>01502 <span class="comment">///</span>
<a name="l01503"></a>01503 <span class="comment">/// Derived from R v1.9.0</span>
<a name="l01504"></a>01504 <span class="comment">///</span>
<a name="l01505"></a>01505 <span class="comment"></span><span class="comment">// Mathlib : A C Library of Special Functions</span>
<a name="l01506"></a>01506 <span class="comment">//</span>
<a name="l01507"></a>01507 <span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<a name="l01508"></a>01508 <span class="comment">// it under the terms of the GNU General Public License as published by</span>
<a name="l01509"></a>01509 <span class="comment">// the Free Software Foundation; either version 2 of the License, or</span>
<a name="l01510"></a>01510 <span class="comment">// (at your option) any later version.</span>
<a name="l01511"></a>01511 <span class="comment">//</span>
<a name="l01512"></a>01512 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l01513"></a>01513 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l01514"></a>01514 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l01515"></a>01515 <span class="comment">// GNU General Public License for more details.</span>
<a name="l01516"></a>01516 <span class="comment">//</span>
<a name="l01517"></a>01517 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l01518"></a>01518 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l01519"></a>01519 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l01520"></a>01520 <span class="comment">//</span>
<a name="l01521"></a>01521 <span class="comment">// SYNOPSIS</span>
<a name="l01522"></a>01522 <span class="comment">//</span>
<a name="l01523"></a>01523 <span class="comment">//   #include &lt;Rmath.h&gt;</span>
<a name="l01524"></a>01524 <span class="comment">//   double rgamma(double a, double scale);</span>
<a name="l01525"></a>01525 <span class="comment">//</span>
<a name="l01526"></a>01526 <span class="comment">// DESCRIPTION</span>
<a name="l01527"></a>01527 <span class="comment">//</span>
<a name="l01528"></a>01528 <span class="comment">//   Random variates from the gamma distribution.</span>
<a name="l01529"></a>01529 <span class="comment">//</span>
<a name="l01530"></a>01530 <span class="comment">// REFERENCES</span>
<a name="l01531"></a>01531 <span class="comment">//</span>
<a name="l01532"></a>01532 <span class="comment">//  [1] Shape parameter a &gt;= 1.  Algorithm GD in:</span>
<a name="l01533"></a>01533 <span class="comment">//</span>
<a name="l01534"></a>01534 <span class="comment">//  Ahrens, J.H. and Dieter, U. (1982).</span>
<a name="l01535"></a>01535 <span class="comment">//  Generating gamma variates by a modified</span>
<a name="l01536"></a>01536 <span class="comment">//  rejection technique.</span>
<a name="l01537"></a>01537 <span class="comment">//  Comm. ACM, 25, 47-54.</span>
<a name="l01538"></a>01538 <span class="comment">//</span>
<a name="l01539"></a>01539 <span class="comment">//</span>
<a name="l01540"></a>01540 <span class="comment">//  [2] Shape parameter 0 &lt; a &lt; 1. Algorithm GS in:</span>
<a name="l01541"></a>01541 <span class="comment">//</span>
<a name="l01542"></a>01542 <span class="comment">//  Ahrens, J.H. and Dieter, U. (1974).</span>
<a name="l01543"></a>01543 <span class="comment">//  Computer methods for sampling from gamma, beta,</span>
<a name="l01544"></a>01544 <span class="comment">//  poisson and binomial distributions.</span>
<a name="l01545"></a>01545 <span class="comment">//  Computing, 12, 223-246.</span>
<a name="l01546"></a>01546 <span class="comment">//</span>
<a name="l01547"></a>01547 <span class="comment">//   Input: a = parameter (mean) of the standard gamma distribution.</span>
<a name="l01548"></a>01548 <span class="comment">//   Output: a variate from the gamma(a)-distribution</span>
<a name="l01549"></a>01549 <span class="comment">// </span>
<a name="l01550"></a>01550 <span class="keywordtype">double</span> 
<a name="l01551"></a><a class="code" href="classlot.html#7afffff162938dd57de9fe7f18267fd8">01551</a> <a class="code" href="classlot.html#7afffff162938dd57de9fe7f18267fd8">lot::gamma</a>(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> scale) {
<a name="l01552"></a>01552   <span class="comment">/* Constants : */</span>
<a name="l01553"></a>01553   <span class="keyword">const</span> <span class="keywordtype">double</span> sqrt32 = 5.656854;
<a name="l01554"></a>01554   <span class="keyword">const</span> <span class="keywordtype">double</span> exp_m1 = 0.36787944117144232159;<span class="comment">/* exp(-1) = 1/e */</span>
<a name="l01555"></a>01555 
<a name="l01556"></a>01556   <span class="comment">/* Coefficients q[k] - for q0 = sum(q[k]*a^(-k))</span>
<a name="l01557"></a>01557 <span class="comment">   * Coefficients a[k] - for q = q0+(t*t/2)*sum(a[k]*v^k)</span>
<a name="l01558"></a>01558 <span class="comment">   * Coefficients e[k] - for exp(q)-1 = sum(e[k]*q^k)</span>
<a name="l01559"></a>01559 <span class="comment">   */</span>
<a name="l01560"></a>01560   <span class="keyword">const</span> <span class="keywordtype">double</span> q1 = 0.04166669;
<a name="l01561"></a>01561   <span class="keyword">const</span> <span class="keywordtype">double</span> q2 = 0.02083148;
<a name="l01562"></a>01562   <span class="keyword">const</span> <span class="keywordtype">double</span> q3 = 0.00801191;
<a name="l01563"></a>01563   <span class="keyword">const</span> <span class="keywordtype">double</span> q4 = 0.00144121;
<a name="l01564"></a>01564   <span class="keyword">const</span> <span class="keywordtype">double</span> q5 = -7.388e-5;
<a name="l01565"></a>01565   <span class="keyword">const</span> <span class="keywordtype">double</span> q6 = 2.4511e-4;
<a name="l01566"></a>01566   <span class="keyword">const</span> <span class="keywordtype">double</span> q7 = 2.424e-4;
<a name="l01567"></a>01567 
<a name="l01568"></a>01568   <span class="keyword">const</span> <span class="keywordtype">double</span> a1 = 0.3333333;
<a name="l01569"></a>01569   <span class="keyword">const</span> <span class="keywordtype">double</span> a2 = -0.250003;
<a name="l01570"></a>01570   <span class="keyword">const</span> <span class="keywordtype">double</span> a3 = 0.2000062;
<a name="l01571"></a>01571   <span class="keyword">const</span> <span class="keywordtype">double</span> a4 = -0.1662921;
<a name="l01572"></a>01572   <span class="keyword">const</span> <span class="keywordtype">double</span> a5 = 0.1423657;
<a name="l01573"></a>01573   <span class="keyword">const</span> <span class="keywordtype">double</span> a6 = -0.1367177;
<a name="l01574"></a>01574   <span class="keyword">const</span> <span class="keywordtype">double</span> a7 = 0.1233795;
<a name="l01575"></a>01575 
<a name="l01576"></a>01576   <span class="comment">/* State variables [FIXME for threading!] :*/</span>
<a name="l01577"></a>01577   <span class="keyword">static</span> <span class="keywordtype">double</span> aa = 0.;
<a name="l01578"></a>01578   <span class="keyword">static</span> <span class="keywordtype">double</span> aaa = 0.;
<a name="l01579"></a>01579   <span class="keyword">static</span> <span class="keywordtype">double</span> s, s2, d;    <span class="comment">/* no. 1 (step 1) */</span>
<a name="l01580"></a>01580   <span class="keyword">static</span> <span class="keywordtype">double</span> q0, b, si, c;<span class="comment">/* no. 2 (step 4) */</span>
<a name="l01581"></a>01581 
<a name="l01582"></a>01582   <span class="keywordtype">double</span> e, p, q, r, <a class="code" href="classlot.html#2c92917eba7874183e6f3672c9ac2f61">t</a>, u, v, w, x, ret_val;
<a name="l01583"></a>01583 
<a name="l01584"></a>01584   <span class="keywordflow">if</span> (a &lt; 1.) { <span class="comment">/* GS algorithm for parameters a &lt; 1 */</span>
<a name="l01585"></a>01585     e = 1.0 + exp_m1 * a;
<a name="l01586"></a>01586     <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l01587"></a>01587             p = e * <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l01588"></a>01588             <span class="keywordflow">if</span> (p &gt;= 1.0) {
<a name="l01589"></a>01589         x = -log((e - p) / a);
<a name="l01590"></a>01590         <span class="keywordflow">if</span> (<a class="code" href="lot_8cpp.html#1157a8d237f8bb89b614435b4ee1cbef">exp_rand</a>() &gt;= (1.0 - a) * log(x))
<a name="l01591"></a>01591           <span class="keywordflow">break</span>;
<a name="l01592"></a>01592             } <span class="keywordflow">else</span> {
<a name="l01593"></a>01593         x = exp(log(p) / a);
<a name="l01594"></a>01594         <span class="keywordflow">if</span> (<a class="code" href="lot_8cpp.html#1157a8d237f8bb89b614435b4ee1cbef">exp_rand</a>() &gt;= x)
<a name="l01595"></a>01595           <span class="keywordflow">break</span>;
<a name="l01596"></a>01596             }
<a name="l01597"></a>01597     }
<a name="l01598"></a>01598     <span class="keywordflow">return</span> scale * x;
<a name="l01599"></a>01599   }
<a name="l01600"></a>01600 
<a name="l01601"></a>01601   <span class="comment">/* --- a &gt;= 1 : GD algorithm --- */</span>
<a name="l01602"></a>01602   <span class="comment">/* Step 1: Recalculations of s2, s, d if a has changed */</span>
<a name="l01603"></a>01603   <span class="keywordflow">if</span> (a != aa) {
<a name="l01604"></a>01604     aa = a;
<a name="l01605"></a>01605     s2 = a - 0.5;
<a name="l01606"></a>01606     s = sqrt(s2);
<a name="l01607"></a>01607     d = sqrt32 - s * 12.0;
<a name="l01608"></a>01608   }
<a name="l01609"></a>01609   <span class="comment">/* Step 2: t = standard normal deviate,</span>
<a name="l01610"></a>01610 <span class="comment">     x = (s,1/2) -normal deviate. */</span>
<a name="l01611"></a>01611   <span class="comment">/* immediate acceptance (i) */</span>
<a name="l01612"></a>01612   t = <a class="code" href="lot_8cpp.html#40a3b93beb4e8ce7a943839de82bb661">norm_rand</a>();
<a name="l01613"></a>01613   x = s + 0.5 * t;
<a name="l01614"></a>01614   ret_val = x * x;
<a name="l01615"></a>01615   <span class="keywordflow">if</span> (t &gt;= 0.0) {
<a name="l01616"></a>01616     <span class="keywordflow">return</span> scale * ret_val;
<a name="l01617"></a>01617   }
<a name="l01618"></a>01618   <span class="comment">/* Step 3: u = 0,1 - uniform sample. squeeze acceptance (s) */</span>
<a name="l01619"></a>01619   u = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l01620"></a>01620   <span class="keywordflow">if</span> (d * u &lt;= t * t * t) {
<a name="l01621"></a>01621     <span class="keywordflow">return</span> scale * ret_val;
<a name="l01622"></a>01622   }
<a name="l01623"></a>01623   <span class="comment">/* Step 4: recalculations of q0, b, si, c if necessary */</span>
<a name="l01624"></a>01624   <span class="keywordflow">if</span> (a != aaa) {
<a name="l01625"></a>01625     aaa = a;
<a name="l01626"></a>01626     r = 1.0 / a;
<a name="l01627"></a>01627     q0 = ((((((q7 * r + q6) * r + q5) * r + q4) * r + q3) * r
<a name="l01628"></a>01628            + q2) * r + q1) * r;
<a name="l01629"></a>01629     <span class="comment">/* Approximation depending on size of parameter a */</span>
<a name="l01630"></a>01630     <span class="comment">/* The constants in the expressions for b, si and c */</span>
<a name="l01631"></a>01631     <span class="comment">/* were established by numerical experiments */</span>
<a name="l01632"></a>01632     <span class="keywordflow">if</span> (a &lt;= 3.686) {
<a name="l01633"></a>01633             b = 0.463 + s + 0.178 * s2;
<a name="l01634"></a>01634             si = 1.235;
<a name="l01635"></a>01635             c = 0.195 / s - 0.079 + 0.16 * s;
<a name="l01636"></a>01636     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a &lt;= 13.022) {
<a name="l01637"></a>01637             b = 1.654 + 0.0076 * s2;
<a name="l01638"></a>01638             si = 1.68 / s + 0.275;
<a name="l01639"></a>01639             c = 0.062 / s + 0.024;
<a name="l01640"></a>01640     } <span class="keywordflow">else</span> {
<a name="l01641"></a>01641             b = 1.77;
<a name="l01642"></a>01642             si = 0.75;
<a name="l01643"></a>01643             c = 0.1515 / s;
<a name="l01644"></a>01644     }
<a name="l01645"></a>01645   }
<a name="l01646"></a>01646   <span class="comment">/* Step 5: no quotient test if x not positive */</span>
<a name="l01647"></a>01647   <span class="keywordflow">if</span> (x &gt; 0.0) {
<a name="l01648"></a>01648     <span class="comment">/* Step 6: calculation of v and quotient q */</span>
<a name="l01649"></a>01649     v = t / (s + s);
<a name="l01650"></a>01650     <span class="keywordflow">if</span> (fabs(v) &lt;= 0.25) {
<a name="l01651"></a>01651             q = q0 + 0.5 * t * t * ((((((a7 * v + a6) * v + a5) * v + a4) * v
<a name="l01652"></a>01652                                 + a3) * v + a2) * v + a1) * v;
<a name="l01653"></a>01653     } <span class="keywordflow">else</span> {
<a name="l01654"></a>01654             q = q0 - s * t + 0.25 * t * t + (s2 + s2) * log(1.0 + v);
<a name="l01655"></a>01655 
<a name="l01656"></a>01656     }
<a name="l01657"></a>01657     <span class="comment">/* Step 7: quotient acceptance (q) */</span>
<a name="l01658"></a>01658     <span class="keywordflow">if</span> (log(1.0 - u) &lt;= q) {
<a name="l01659"></a>01659             <span class="keywordflow">return</span> scale * ret_val;
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661   }
<a name="l01662"></a>01662   <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l01663"></a>01663     <span class="comment">/* Step 8: e = standard exponential deviate</span>
<a name="l01664"></a>01664 <span class="comment">     *  u =  0,1 -uniform deviate</span>
<a name="l01665"></a>01665 <span class="comment">     *  t = (b,si)-double exponential (laplace) sample */</span>
<a name="l01666"></a>01666     e = <a class="code" href="lot_8cpp.html#1157a8d237f8bb89b614435b4ee1cbef">exp_rand</a>();
<a name="l01667"></a>01667     u = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l01668"></a>01668     u = u + u - 1.0;
<a name="l01669"></a>01669     <span class="keywordflow">if</span> (u &lt; 0.0) {
<a name="l01670"></a>01670             t = b - si * e;
<a name="l01671"></a>01671     } <span class="keywordflow">else</span> {
<a name="l01672"></a>01672             t = b + si * e;
<a name="l01673"></a>01673     }
<a name="l01674"></a>01674     <span class="comment">/* Step      9:  rejection if t &lt; tau(1) = -0.71874483771719 */</span>
<a name="l01675"></a>01675     <span class="keywordflow">if</span> (t &gt;= -0.71874483771719) {
<a name="l01676"></a>01676             <span class="comment">/* Step 10:  calculation of v and quotient q */</span>
<a name="l01677"></a>01677             v = t / (s + s);
<a name="l01678"></a>01678             <span class="keywordflow">if</span> (fabs(v) &lt;= 0.25) {
<a name="l01679"></a>01679         q = q0 + 0.5 * t * t *
<a name="l01680"></a>01680           ((((((a7 * v + a6) * v + a5) * v + a4) * v + a3) * v
<a name="l01681"></a>01681             + a2) * v + a1) * v;
<a name="l01682"></a>01682             } <span class="keywordflow">else</span> {
<a name="l01683"></a>01683         q = q0 - s * t + 0.25 * t * t + (s2 + s2) * log(1.0 + v);
<a name="l01684"></a>01684       }
<a name="l01685"></a>01685             <span class="comment">/* Step 11:  hat acceptance (h) */</span>
<a name="l01686"></a>01686             <span class="comment">/* (if q not positive go to step 8) */</span>
<a name="l01687"></a>01687             <span class="keywordflow">if</span> (q &gt; 0.0) {
<a name="l01688"></a>01688         w = expm1(q);
<a name="l01689"></a>01689         <span class="comment">/*  ^^^^^ original code had approximation with rel.err &lt; 2e-7 */</span>
<a name="l01690"></a>01690         <span class="comment">/* if t is rejected sample again at step 8 */</span>
<a name="l01691"></a>01691         <span class="keywordflow">if</span> (c * fabs(u) &lt;= w * exp(e - 0.5 * t * t)) {
<a name="l01692"></a>01692           <span class="keywordflow">break</span>;
<a name="l01693"></a>01693         }
<a name="l01694"></a>01694             }
<a name="l01695"></a>01695     }
<a name="l01696"></a>01696   } <span class="comment">/* repeat .. until  `t' is accepted */</span>
<a name="l01697"></a>01697   x = s + 0.5 * t;
<a name="l01698"></a>01698   <span class="keywordflow">return</span> scale * x * x;
<a name="l01699"></a>01699 }
<a name="l01700"></a>01700 <span class="comment"></span>
<a name="l01701"></a>01701 <span class="comment">/// Returns a geometric deviate</span>
<a name="l01702"></a>01702 <span class="comment">///</span>
<a name="l01703"></a>01703 <span class="comment">/// \f[ f(x) = p(1-p)^x \f]</span>
<a name="l01704"></a>01704 <span class="comment">///</span>
<a name="l01705"></a>01705 <span class="comment">/// \param p         the parameter of the geometric distribution</span>
<a name="l01706"></a>01706 <span class="comment">///</span>
<a name="l01707"></a>01707 <span class="comment">/// \f[ \mbox{E}(x) = \frac{1-p}{p} \f]</span>
<a name="l01708"></a>01708 <span class="comment">/// \f[ \mbox{Var}(x) = \frac{1-p}{p^2} \f]</span>
<a name="l01709"></a>01709 <span class="comment">///</span>
<a name="l01710"></a>01710 <span class="comment">/// Derived from R v2.0. Does not check isnan() on x and p. Does not</span>
<a name="l01711"></a>01711 <span class="comment">/// check for 0 &lt; p &lt; 1.</span>
<a name="l01712"></a>01712 <span class="comment">///</span>
<a name="l01713"></a>01713 <span class="comment"></span><span class="comment">//</span>
<a name="l01714"></a>01714 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l01715"></a>01715 <span class="comment">//  Copyright (C) 1998 Ross Ihaka and the R Development Core Team.</span>
<a name="l01716"></a>01716 <span class="comment">//  Copyright (C) 2000 The R Development Core Team</span>
<a name="l01717"></a>01717 <span class="comment">//</span>
<a name="l01718"></a>01718 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l01719"></a>01719 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l01720"></a>01720 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l01721"></a>01721 <span class="comment">//  (at your option) any later version.</span>
<a name="l01722"></a>01722 <span class="comment">//</span>
<a name="l01723"></a>01723 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l01724"></a>01724 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l01725"></a>01725 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l01726"></a>01726 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l01727"></a>01727 <span class="comment">//</span>
<a name="l01728"></a>01728 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l01729"></a>01729 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l01730"></a>01730 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l01731"></a>01731 <span class="comment">//</span>
<a name="l01732"></a>01732 <span class="comment">//  SYNOPSIS</span>
<a name="l01733"></a>01733 <span class="comment">//</span>
<a name="l01734"></a>01734 <span class="comment">//    #include &lt;Rmath.h&gt;</span>
<a name="l01735"></a>01735 <span class="comment">//    double rgeom(double p);</span>
<a name="l01736"></a>01736 <span class="comment">//</span>
<a name="l01737"></a>01737 <span class="comment">//  DESCRIPTION</span>
<a name="l01738"></a>01738 <span class="comment">//</span>
<a name="l01739"></a>01739 <span class="comment">//    Random variates from the geometric distribution.</span>
<a name="l01740"></a>01740 <span class="comment">//</span>
<a name="l01741"></a>01741 <span class="comment">//  NOTES</span>
<a name="l01742"></a>01742 <span class="comment">//</span>
<a name="l01743"></a>01743 <span class="comment">//    We generate lambda as exponential with scale parameter</span>
<a name="l01744"></a>01744 <span class="comment">//    p / (1 - p).  Return a Poisson deviate with mean lambda.</span>
<a name="l01745"></a>01745 <span class="comment">//</span>
<a name="l01746"></a>01746 <span class="comment">//  REFERENCE</span>
<a name="l01747"></a>01747 <span class="comment">//</span>
<a name="l01748"></a>01748 <span class="comment">//    Devroye, L. (1986).</span>
<a name="l01749"></a>01749 <span class="comment">//    Non-Uniform Random Variate Generation.</span>
<a name="l01750"></a>01750 <span class="comment">//    New York: Springer-Verlag.</span>
<a name="l01751"></a>01751 <span class="comment">//    Page 480.</span>
<a name="l01752"></a>01752 <span class="comment">//</span>
<a name="l01753"></a>01753 <span class="keywordtype">double</span> 
<a name="l01754"></a><a class="code" href="classlot.html#0a6b770ba0a801ae55d7c1adf26f7646">01754</a> <a class="code" href="classlot.html#0a6b770ba0a801ae55d7c1adf26f7646">lot::geom</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> p) {
<a name="l01755"></a>01755   <span class="keywordflow">return</span> <a class="code" href="classlot.html#c5222f371da3454827e66ea8ae0c0890">poisson</a>(<a class="code" href="lot_8cpp.html#1157a8d237f8bb89b614435b4ee1cbef">exp_rand</a>() * ((1 - p) / p));
<a name="l01756"></a>01756 }
<a name="l01757"></a>01757 <span class="comment"></span>
<a name="l01758"></a>01758 <span class="comment">/// Returns a hypergeometric variate</span>
<a name="l01759"></a>01759 <span class="comment">///</span>
<a name="l01760"></a>01760 <span class="comment">///</span>
<a name="l01761"></a>01761 <span class="comment">/// \f[ f(x) = \frac{{w \choose x}{b \choose n-x}}{{w+b \choose n}} \f]</span>
<a name="l01762"></a>01762 <span class="comment">///</span>
<a name="l01763"></a>01763 <span class="comment">/// \param nn1        The number of white balls in the urn (\f$w\f$)</span>
<a name="l01764"></a>01764 <span class="comment">/// \param nn2        The number of black balls in the urn (\f$b\f$)</span>
<a name="l01765"></a>01765 <span class="comment">/// \param kk         The sample size (\f$n\f$)</span>
<a name="l01766"></a>01766 <span class="comment">///</span>
<a name="l01767"></a>01767 <span class="comment">/// \f[ \mbox{E}(x) = n(\frac{w}{w+b}) \f]</span>
<a name="l01768"></a>01768 <span class="comment">/// \f[ \mbox{Var}(x) = \frac{n(\frac{w}{w+b})(1-\frac{w}{w+b})((w+b)-n)}{w+b-1} \f]</span>
<a name="l01769"></a>01769 <span class="comment">///</span>
<a name="l01770"></a>01770 <span class="comment">/// The code is modified from R v2.0 to take unsigned integer arguments </span>
<a name="l01771"></a>01771 <span class="comment">/// rather than doubles. isfinite() checks are no longer needed. Check for</span>
<a name="l01772"></a>01772 <span class="comment">/// n &lt; r + b not done.</span>
<a name="l01773"></a>01773 <span class="comment">///</span>
<a name="l01774"></a>01774 <span class="comment"></span><span class="comment">//</span>
<a name="l01775"></a>01775 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l01776"></a>01776 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l01777"></a>01777 <span class="comment">//  Copyright (C) 2000-2001 The R Development Core Team</span>
<a name="l01778"></a>01778 <span class="comment">//</span>
<a name="l01779"></a>01779 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l01780"></a>01780 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l01781"></a>01781 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l01782"></a>01782 <span class="comment">//  (at your option) any later version.</span>
<a name="l01783"></a>01783 <span class="comment">//</span>
<a name="l01784"></a>01784 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l01785"></a>01785 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l01786"></a>01786 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l01787"></a>01787 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l01788"></a>01788 <span class="comment">//</span>
<a name="l01789"></a>01789 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l01790"></a>01790 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l01791"></a>01791 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l01792"></a>01792 <span class="comment">//</span>
<a name="l01793"></a>01793 <span class="comment">//  SYNOPSIS</span>
<a name="l01794"></a>01794 <span class="comment">//</span>
<a name="l01795"></a>01795 <span class="comment">//    #include &lt;Rmath.h&gt;</span>
<a name="l01796"></a>01796 <span class="comment">//    double rhyper(double NR, double NB, double n);</span>
<a name="l01797"></a>01797 <span class="comment">//</span>
<a name="l01798"></a>01798 <span class="comment">//  DESCRIPTION</span>
<a name="l01799"></a>01799 <span class="comment">//</span>
<a name="l01800"></a>01800 <span class="comment">//    Random variates from the hypergeometric distribution.</span>
<a name="l01801"></a>01801 <span class="comment">//    Returns the number of white balls drawn when kk balls</span>
<a name="l01802"></a>01802 <span class="comment">//    are drawn at random from an urn containing nn1 white</span>
<a name="l01803"></a>01803 <span class="comment">//    and nn2 black balls.</span>
<a name="l01804"></a>01804 <span class="comment">//</span>
<a name="l01805"></a>01805 <span class="comment">//  REFERENCE</span>
<a name="l01806"></a>01806 <span class="comment">//</span>
<a name="l01807"></a>01807 <span class="comment">//    V. Kachitvichyanukul and B. Schmeiser (1985).</span>
<a name="l01808"></a>01808 <span class="comment">//    ``Computer generation of hypergeometric random variates,''</span>
<a name="l01809"></a>01809 <span class="comment">//    Journal of Statistical Computation and Simulation 22, 127-145.</span>
<a name="l01810"></a>01810 <span class="comment">//</span>
<a name="l01811"></a>01811 <span class="keywordtype">int</span>
<a name="l01812"></a><a class="code" href="classlot.html#b78156c1172acfae7f9308306477cbdb">01812</a> <a class="code" href="classlot.html#b78156c1172acfae7f9308306477cbdb">lot::hypergeom</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> nn1, <span class="keyword">const</span> <span class="keywordtype">int</span> nn2, <span class="keyword">const</span> <span class="keywordtype">int</span> kk) {
<a name="l01813"></a>01813   <span class="keyword">const</span> <span class="keywordtype">double</span> con = 57.56462733;
<a name="l01814"></a>01814   <span class="keyword">const</span> <span class="keywordtype">double</span> deltal = 0.0078;
<a name="l01815"></a>01815   <span class="keyword">const</span> <span class="keywordtype">double</span> deltau = 0.0034;
<a name="l01816"></a>01816   <span class="keyword">const</span> <span class="keywordtype">double</span> scale = 1e25;
<a name="l01817"></a>01817 
<a name="l01818"></a>01818   <span class="keywordtype">int</span> i, ix;
<a name="l01819"></a>01819   <span class="keywordtype">bool</span> reject, setup1, setup2;
<a name="l01820"></a>01820     
<a name="l01821"></a>01821   <span class="keywordtype">double</span> e, <a class="code" href="classlot.html#74885f27b6d8afcc1e7c202f7644fbfc">f</a>, g, p, r, <a class="code" href="classlot.html#2c92917eba7874183e6f3672c9ac2f61">t</a>, u, v, y;
<a name="l01822"></a>01822   <span class="keywordtype">double</span> de, dg, dr, ds, <a class="code" href="namespaceDensity.html#478294fe482091a4528fe961c348566d">dt</a>, gl, gu, nk, nm, ub;
<a name="l01823"></a>01823   <span class="keywordtype">double</span> xk, xm, xn, y1, ym, yn, yk, alv;
<a name="l01824"></a>01824 
<a name="l01825"></a>01825   <span class="comment">/* These should become `thread_local globals' : */</span>
<a name="l01826"></a>01826   <span class="keyword">static</span> <span class="keywordtype">int</span> ks = -1;
<a name="l01827"></a>01827   <span class="keyword">static</span> <span class="keywordtype">int</span> n1s = -1, n2s = -1;
<a name="l01828"></a>01828 
<a name="l01829"></a>01829   <span class="keyword">static</span> <span class="keywordtype">int</span> k, m;
<a name="l01830"></a>01830   <span class="keyword">static</span> <span class="keywordtype">int</span> minjx, maxjx, n1, n2;
<a name="l01831"></a>01831 
<a name="l01832"></a>01832   <span class="keyword">static</span> <span class="keywordtype">double</span> a, d, s, w;
<a name="l01833"></a>01833   <span class="keyword">static</span> <span class="keywordtype">double</span> tn, xl, xr, kl, kr, lamdl, lamdr, p1, p2, p3;
<a name="l01834"></a>01834 
<a name="l01835"></a>01835   <span class="comment">/* if new parameter values, initialize */</span>
<a name="l01836"></a>01836   reject = <span class="keyword">true</span>;
<a name="l01837"></a>01837   <span class="keywordflow">if</span> (nn1 != n1s || nn2 != n2s) {
<a name="l01838"></a>01838     setup1 = <span class="keyword">true</span>;      setup2 = <span class="keyword">true</span>;
<a name="l01839"></a>01839   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kk != ks) {
<a name="l01840"></a>01840     setup1 = <span class="keyword">false</span>;     setup2 = <span class="keyword">true</span>;
<a name="l01841"></a>01841   } <span class="keywordflow">else</span> {
<a name="l01842"></a>01842     setup1 = <span class="keyword">false</span>;     setup2 = <span class="keyword">false</span>;
<a name="l01843"></a>01843   }
<a name="l01844"></a>01844   <span class="keywordflow">if</span> (setup1) {
<a name="l01845"></a>01845     n1s = nn1;
<a name="l01846"></a>01846     n2s = nn2;
<a name="l01847"></a>01847     tn = nn1 + nn2;
<a name="l01848"></a>01848     <span class="keywordflow">if</span> (nn1 &lt;= nn2) {
<a name="l01849"></a>01849             n1 = nn1;
<a name="l01850"></a>01850             n2 = nn2;
<a name="l01851"></a>01851     } <span class="keywordflow">else</span> {
<a name="l01852"></a>01852             n1 = nn2;
<a name="l01853"></a>01853             n2 = nn1;
<a name="l01854"></a>01854     }
<a name="l01855"></a>01855   }
<a name="l01856"></a>01856   <span class="keywordflow">if</span> (setup2) {
<a name="l01857"></a>01857     ks = kk;
<a name="l01858"></a>01858     <span class="keywordflow">if</span> (kk + kk &gt;= tn) {
<a name="l01859"></a>01859             k = static_cast&lt;int&gt;(tn - kk);
<a name="l01860"></a>01860     } <span class="keywordflow">else</span> {
<a name="l01861"></a>01861             k = kk;
<a name="l01862"></a>01862     }
<a name="l01863"></a>01863   }
<a name="l01864"></a>01864   <span class="keywordflow">if</span> (setup1 || setup2) {
<a name="l01865"></a>01865     m = static_cast&lt;int&gt;((k + 1.0) * (n1 + 1.0) / (tn + 2.0));
<a name="l01866"></a>01866     minjx = imax2(0, k - n2);
<a name="l01867"></a>01867     maxjx = imin2(n1, k);
<a name="l01868"></a>01868   }
<a name="l01869"></a>01869   <span class="comment">/* generate random variate --- Three basic cases */</span>
<a name="l01870"></a>01870 
<a name="l01871"></a>01871   <span class="keywordflow">if</span> (minjx == maxjx) { <span class="comment">/* I: degenerate distribution ---------------- */</span>
<a name="l01872"></a>01872     ix = maxjx;
<a name="l01873"></a>01873     <span class="comment">/* return ix;</span>
<a name="l01874"></a>01874 <span class="comment">       No, need to unmangle &lt;TSL&gt;*/</span>
<a name="l01875"></a>01875     <span class="comment">/* return appropriate variate */</span>
<a name="l01876"></a>01876 
<a name="l01877"></a>01877     <span class="keywordflow">if</span> (kk + kk &gt;= tn) {
<a name="l01878"></a>01878       <span class="keywordflow">if</span> (nn1 &gt; nn2) {
<a name="l01879"></a>01879         ix = kk - nn2 + ix;
<a name="l01880"></a>01880       } <span class="keywordflow">else</span> {
<a name="l01881"></a>01881         ix = nn1 - ix;
<a name="l01882"></a>01882       }
<a name="l01883"></a>01883     } <span class="keywordflow">else</span> {
<a name="l01884"></a>01884       <span class="keywordflow">if</span> (nn1 &gt; nn2)
<a name="l01885"></a>01885         ix = kk - ix;
<a name="l01886"></a>01886     }
<a name="l01887"></a>01887     <span class="keywordflow">return</span> ix;
<a name="l01888"></a>01888 
<a name="l01889"></a>01889   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m - minjx &lt; 10) { <span class="comment">/* II: inverse transformation ---------- */</span>
<a name="l01890"></a>01890     <span class="keywordflow">if</span> (setup1 || setup2) {
<a name="l01891"></a>01891             <span class="keywordflow">if</span> (k &lt; n2) {
<a name="l01892"></a>01892         w = exp(con + afc(n2) + afc(n1 + n2 - k)
<a name="l01893"></a>01893                 - afc(n2 - k) - afc(n1 + n2));
<a name="l01894"></a>01894             } <span class="keywordflow">else</span> {
<a name="l01895"></a>01895         w = exp(con + afc(n1) + afc(k)
<a name="l01896"></a>01896                 - afc(k - n2) - afc(n1 + n2));
<a name="l01897"></a>01897             }
<a name="l01898"></a>01898     }
<a name="l01899"></a>01899   L10:
<a name="l01900"></a>01900     p = w;
<a name="l01901"></a>01901     ix = minjx;
<a name="l01902"></a>01902     u = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>() * scale;
<a name="l01903"></a>01903   L20:
<a name="l01904"></a>01904     <span class="keywordflow">if</span> (u &gt; p) {
<a name="l01905"></a>01905             u -= p;
<a name="l01906"></a>01906             p *= (n1 - ix) * (k - ix);
<a name="l01907"></a>01907             ix++;
<a name="l01908"></a>01908             p = p / ix / (n2 - k + ix);
<a name="l01909"></a>01909             <span class="keywordflow">if</span> (ix &gt; maxjx)
<a name="l01910"></a>01910         <span class="keywordflow">goto</span> L10;
<a name="l01911"></a>01911             <span class="keywordflow">goto</span> L20;
<a name="l01912"></a>01912     }
<a name="l01913"></a>01913   } <span class="keywordflow">else</span> { <span class="comment">/* III : h2pe --------------------------------------------- */</span>
<a name="l01914"></a>01914 
<a name="l01915"></a>01915     <span class="keywordflow">if</span> (setup1 || setup2) {
<a name="l01916"></a>01916             s = sqrt((tn - k) * k * n1 * n2 / (tn - 1) / tn / tn);
<a name="l01917"></a>01917 
<a name="l01918"></a>01918             <span class="comment">/* remark: d is defined in reference without int. */</span>
<a name="l01919"></a>01919             <span class="comment">/* the truncation centers the cell boundaries at 0.5 */</span>
<a name="l01920"></a>01920 
<a name="l01921"></a>01921             d = static_cast&lt;int&gt;((1.5 * s) + .5);
<a name="l01922"></a>01922             xl = m - d + .5;
<a name="l01923"></a>01923             xr = m + d + .5;
<a name="l01924"></a>01924             a = afc(m) + afc(n1 - m) + afc(k - m) + afc(n2 - k + m);
<a name="l01925"></a>01925             kl = exp(a - afc(static_cast&lt;int&gt;(xl)) - afc(static_cast&lt;int&gt;(n1 - xl))
<a name="l01926"></a>01926                - afc(static_cast&lt;int&gt;(k - xl))
<a name="l01927"></a>01927                - afc(static_cast&lt;int&gt;(n2 - k + xl)));
<a name="l01928"></a>01928             kr = exp(a - afc(static_cast&lt;int&gt;(xr - 1))
<a name="l01929"></a>01929                - afc(static_cast&lt;int&gt;(n1 - xr + 1))
<a name="l01930"></a>01930                - afc(static_cast&lt;int&gt;(k - xr + 1))
<a name="l01931"></a>01931                - afc(static_cast&lt;int&gt;(n2 - k + xr - 1)));
<a name="l01932"></a>01932             lamdl = -log(xl * (n2 - k + xl) / (n1 - xl + 1) / (k - xl + 1));
<a name="l01933"></a>01933             lamdr = -log((n1 - xr + 1) * (k - xr + 1) / xr / (n2 - k + xr));
<a name="l01934"></a>01934             p1 = d + d;
<a name="l01935"></a>01935             p2 = p1 + kl / lamdl;
<a name="l01936"></a>01936             p3 = p2 + kr / lamdr;
<a name="l01937"></a>01937     }
<a name="l01938"></a>01938   L30:
<a name="l01939"></a>01939     u = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>() * p3;
<a name="l01940"></a>01940     v = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l01941"></a>01941     <span class="keywordflow">if</span> (u &lt; p1) {               <span class="comment">/* rectangular region */</span>
<a name="l01942"></a>01942             ix = static_cast&lt;int&gt;(xl + u);
<a name="l01943"></a>01943     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u &lt;= p2) {       <span class="comment">/* left tail */</span>
<a name="l01944"></a>01944             ix = static_cast&lt;int&gt;(xl + log(v) / lamdl);
<a name="l01945"></a>01945             <span class="keywordflow">if</span> (ix &lt; minjx)
<a name="l01946"></a>01946         <span class="keywordflow">goto</span> L30;
<a name="l01947"></a>01947             v = v * (u - p1) * lamdl;
<a name="l01948"></a>01948     } <span class="keywordflow">else</span> {            <span class="comment">/* right tail */</span>
<a name="l01949"></a>01949             ix = static_cast&lt;int&gt;(xr - log(v) / lamdr);
<a name="l01950"></a>01950             <span class="keywordflow">if</span> (ix &gt; maxjx)
<a name="l01951"></a>01951         <span class="keywordflow">goto</span> L30;
<a name="l01952"></a>01952             v = v * (u - p2) * lamdr;
<a name="l01953"></a>01953     }
<a name="l01954"></a>01954 
<a name="l01955"></a>01955     <span class="comment">/* acceptance/rejection test */</span>
<a name="l01956"></a>01956 
<a name="l01957"></a>01957     <span class="keywordflow">if</span> (m &lt; 100 || ix &lt;= 50) {
<a name="l01958"></a>01958             <span class="comment">/* explicit evaluation */</span>
<a name="l01959"></a>01959             f = 1.0;
<a name="l01960"></a>01960             <span class="keywordflow">if</span> (m &lt; ix) {
<a name="l01961"></a>01961         <span class="keywordflow">for</span> (i = m + 1; i &lt;= ix; i++)
<a name="l01962"></a>01962           f = f * (n1 - i + 1) * (k - i + 1) / (n2 - k + i) / i;
<a name="l01963"></a>01963             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m &gt; ix) {
<a name="l01964"></a>01964         <span class="keywordflow">for</span> (i = ix + 1; i &lt;= m; i++)
<a name="l01965"></a>01965           f = f * i * (n2 - k + i) / (n1 - i) / (k - i);
<a name="l01966"></a>01966             }
<a name="l01967"></a>01967             <span class="keywordflow">if</span> (v &lt;= f) {
<a name="l01968"></a>01968         reject = <span class="keyword">false</span>;
<a name="l01969"></a>01969             }
<a name="l01970"></a>01970     } <span class="keywordflow">else</span> {
<a name="l01971"></a>01971             <span class="comment">/* squeeze using upper and lower bounds */</span>
<a name="l01972"></a>01972             y = ix;
<a name="l01973"></a>01973             y1 = y + 1.0;
<a name="l01974"></a>01974             ym = y - m;
<a name="l01975"></a>01975             yn = n1 - y + 1.0;
<a name="l01976"></a>01976             yk = k - y + 1.0;
<a name="l01977"></a>01977             nk = n2 - k + y1;
<a name="l01978"></a>01978             r = -ym / y1;
<a name="l01979"></a>01979             s = ym / yn;
<a name="l01980"></a>01980             t = ym / yk;
<a name="l01981"></a>01981             e = -ym / nk;
<a name="l01982"></a>01982             g = yn * yk / (y1 * nk) - 1.0;
<a name="l01983"></a>01983             dg = 1.0;
<a name="l01984"></a>01984             <span class="keywordflow">if</span> (g &lt; 0.0)
<a name="l01985"></a>01985         dg = 1.0 + g;
<a name="l01986"></a>01986             gu = g * (1.0 + g * (-0.5 + g / 3.0));
<a name="l01987"></a>01987             gl = gu - .25 * (g * g * g * g) / dg;
<a name="l01988"></a>01988             xm = m + 0.5;
<a name="l01989"></a>01989             xn = n1 - m + 0.5;
<a name="l01990"></a>01990             xk = k - m + 0.5;
<a name="l01991"></a>01991             nm = n2 - k + xm;
<a name="l01992"></a>01992             ub = y * gu - m * gl + deltau
<a name="l01993"></a>01993         + xm * r * (1. + r * (-0.5 + r / 3.0))
<a name="l01994"></a>01994         + xn * s * (1. + s * (-0.5 + s / 3.0))
<a name="l01995"></a>01995         + xk * t * (1. + t * (-0.5 + t / 3.0))
<a name="l01996"></a>01996         + nm * e * (1. + e * (-0.5 + e / 3.0));
<a name="l01997"></a>01997             <span class="comment">/* test against upper bound */</span>
<a name="l01998"></a>01998             alv = log(v);
<a name="l01999"></a>01999             <span class="keywordflow">if</span> (alv &gt; ub) {
<a name="l02000"></a>02000         reject = <span class="keyword">true</span>;
<a name="l02001"></a>02001             } <span class="keywordflow">else</span> {
<a name="l02002"></a>02002                                 <span class="comment">/* test against lower bound */</span>
<a name="l02003"></a>02003         dr = xm * (r * r * r * r);
<a name="l02004"></a>02004         <span class="keywordflow">if</span> (r &lt; 0.0)
<a name="l02005"></a>02005           dr /= (1.0 + r);
<a name="l02006"></a>02006         ds = xn * (s * s * s * s);
<a name="l02007"></a>02007         <span class="keywordflow">if</span> (s &lt; 0.0)
<a name="l02008"></a>02008           ds /= (1.0 + s);
<a name="l02009"></a>02009         dt = xk * (t * t * t * t);
<a name="l02010"></a>02010         <span class="keywordflow">if</span> (t &lt; 0.0)
<a name="l02011"></a>02011           dt /= (1.0 + t);
<a name="l02012"></a>02012         de = nm * (e * e * e * e);
<a name="l02013"></a>02013         <span class="keywordflow">if</span> (e &lt; 0.0)
<a name="l02014"></a>02014           de /= (1.0 + e);
<a name="l02015"></a>02015         <span class="keywordflow">if</span> (alv &lt; ub - 0.25 * (dr + ds + dt + de)
<a name="l02016"></a>02016             + (y + m) * (gl - gu) - deltal) {
<a name="l02017"></a>02017           reject = <span class="keyword">false</span>;
<a name="l02018"></a>02018         } 
<a name="l02019"></a>02019         <span class="keywordflow">else</span> {
<a name="l02020"></a>02020           <span class="comment">/* * Stirling's formula to machine accuracy</span>
<a name="l02021"></a>02021 <span class="comment">           */</span>
<a name="l02022"></a>02022           <span class="keywordflow">if</span> (alv &lt;= (a - afc(ix) - afc(n1 - ix)
<a name="l02023"></a>02023                       - afc(k - ix) - afc(n2 - k + ix))) {
<a name="l02024"></a>02024             reject = <span class="keyword">false</span>;
<a name="l02025"></a>02025           } <span class="keywordflow">else</span> {
<a name="l02026"></a>02026             reject = <span class="keyword">true</span>;
<a name="l02027"></a>02027           }
<a name="l02028"></a>02028         }
<a name="l02029"></a>02029             }
<a name="l02030"></a>02030     }
<a name="l02031"></a>02031     <span class="keywordflow">if</span> (reject)
<a name="l02032"></a>02032             <span class="keywordflow">goto</span> L30;
<a name="l02033"></a>02033   }
<a name="l02034"></a>02034 
<a name="l02035"></a>02035   <span class="comment">/* return appropriate variate */</span>
<a name="l02036"></a>02036 
<a name="l02037"></a>02037   <span class="keywordflow">if</span> (kk + kk &gt;= tn) {
<a name="l02038"></a>02038     <span class="keywordflow">if</span> (nn1 &gt; nn2) {
<a name="l02039"></a>02039             ix = kk - nn2 + ix;
<a name="l02040"></a>02040     } <span class="keywordflow">else</span> {
<a name="l02041"></a>02041             ix = nn1 - ix;
<a name="l02042"></a>02042     }
<a name="l02043"></a>02043   } <span class="keywordflow">else</span> {
<a name="l02044"></a>02044     <span class="keywordflow">if</span> (nn1 &gt; nn2)
<a name="l02045"></a>02045             ix = kk - ix;
<a name="l02046"></a>02046   }
<a name="l02047"></a>02047   <span class="keywordflow">return</span> ix;
<a name="l02048"></a>02048 }
<a name="l02049"></a>02049 <span class="comment"></span>
<a name="l02050"></a>02050 <span class="comment">/// Returns a log-normal deviate</span>
<a name="l02051"></a>02051 <span class="comment">///</span>
<a name="l02052"></a>02052 <span class="comment">/// \f[ f(x) = \frac{1}{\sigma x\sqrt{2\pi}}e^{-\frac{(\log(x) - \mu)^2}{2\sigma^2}} \f]</span>
<a name="l02053"></a>02053 <span class="comment">///</span>
<a name="l02054"></a>02054 <span class="comment">/// \param logmean   logarithm of the mean of the corresponding normal (\f$\mu\f$)</span>
<a name="l02055"></a>02055 <span class="comment">/// \param logsd     logarithm of the sd of the corresponding normal (\f$\sigma\f$)</span>
<a name="l02056"></a>02056 <span class="comment">///</span>
<a name="l02057"></a>02057 <span class="comment">/// \f[ \mbox{E}(x) = e^{\mu + \sigma^2/2} \f]</span>
<a name="l02058"></a>02058 <span class="comment">/// \f[ \mbox{Var}(x) = e^{2\mu + \sigma^2}(e^{\sigma^2}-1) \f]</span>
<a name="l02059"></a>02059 <span class="comment">/// \f[ \mbox{mode} = \frac{e^\mu}{e^{\sigma^2}} \f]</span>
<a name="l02060"></a>02060 <span class="comment">/// \f[ \mbox{median} = e^\mu \f]</span>
<a name="l02061"></a>02061 <span class="comment">///</span>
<a name="l02062"></a>02062 <span class="comment">/// Derived from R v2.0. Does not do isnan() checks on arguments. Does</span>
<a name="l02063"></a>02063 <span class="comment">/// not check for sigma &gt; 0.</span>
<a name="l02064"></a>02064 <span class="comment"></span><span class="comment">//</span>
<a name="l02065"></a>02065 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l02066"></a>02066 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l02067"></a>02067 <span class="comment">//  Copyright (C) 2000--2001  The R Development Core Team</span>
<a name="l02068"></a>02068 <span class="comment">//</span>
<a name="l02069"></a>02069 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l02070"></a>02070 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l02071"></a>02071 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l02072"></a>02072 <span class="comment">//  (at your option) any later version.</span>
<a name="l02073"></a>02073 <span class="comment">//</span>
<a name="l02074"></a>02074 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l02075"></a>02075 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l02076"></a>02076 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l02077"></a>02077 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l02078"></a>02078 <span class="comment">//</span>
<a name="l02079"></a>02079 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l02080"></a>02080 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l02081"></a>02081 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l02082"></a>02082 <span class="comment">//</span>
<a name="l02083"></a>02083 <span class="comment">//  SYNOPSIS</span>
<a name="l02084"></a>02084 <span class="comment">//</span>
<a name="l02085"></a>02085 <span class="comment">//    #include &lt;Rmath.h&gt;</span>
<a name="l02086"></a>02086 <span class="comment">//    double rlnorm(double logmean, double logsd);</span>
<a name="l02087"></a>02087 <span class="comment">//</span>
<a name="l02088"></a>02088 <span class="comment">//  DESCRIPTION</span>
<a name="l02089"></a>02089 <span class="comment">//</span>
<a name="l02090"></a>02090 <span class="comment">//    Random variates from the lognormal distribution.</span>
<a name="l02091"></a>02091 <span class="comment">//</span>
<a name="l02092"></a>02092 <span class="keywordtype">double</span> 
<a name="l02093"></a><a class="code" href="classlot.html#e67af06c631147d61e699ffa79b18862">02093</a> <a class="code" href="classlot.html#e67af06c631147d61e699ffa79b18862">lot::lnorm</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> logmean, <span class="keyword">const</span> <span class="keywordtype">double</span> logsd) {
<a name="l02094"></a>02094     <span class="keywordflow">return</span> exp(<a class="code" href="classlot.html#8ae43514866e857aba6153216e896c59">norm</a>(logmean, logsd));
<a name="l02095"></a>02095 }
<a name="l02096"></a>02096 <span class="comment"></span>
<a name="l02097"></a>02097 <span class="comment">/// Returns a logistic variate</span>
<a name="l02098"></a>02098 <span class="comment">///</span>
<a name="l02099"></a>02099 <span class="comment">/// \f[ f(x) = \frac{1}{s}\frac{e^{\frac{x-m}{s}}}{(1 + e^{\frac{x-m}{s}})^2} \f]</span>
<a name="l02100"></a>02100 <span class="comment">///</span>
<a name="l02101"></a>02101 <span class="comment">/// or equivalently (dividing numerator and denominator by \f$e^{2\frac{x-m}{s}}\f$)</span>
<a name="l02102"></a>02102 <span class="comment">///</span>
<a name="l02103"></a>02103 <span class="comment">/// \f[ f(x) = \frac{1}{s}\frac{e^{\frac{-(x-m)}{s}}}{(1 + e^{\frac{-(x-m)}{s}})^2} \f]</span>
<a name="l02104"></a>02104 <span class="comment">///</span>
<a name="l02105"></a>02105 <span class="comment">/// \param location         the location parameter (\f$m\f$)</span>
<a name="l02106"></a>02106 <span class="comment">/// \param scale            the scale parameter (\f$s\f$)</span>
<a name="l02107"></a>02107 <span class="comment">///</span>
<a name="l02108"></a>02108 <span class="comment">/// \f[ \mbox{E}(x) = m \f]</span>
<a name="l02109"></a>02109 <span class="comment">/// \f[ \mbox{Var}(x) = \frac{\pi^2s^2}{3} \f]</span>
<a name="l02110"></a>02110 <span class="comment">///</span>
<a name="l02111"></a>02111 <span class="comment">/// Derived from R v2.0. Does not do isnan() checks on parameters. Does</span>
<a name="l02112"></a>02112 <span class="comment">/// not check for scale &gt; 0.</span>
<a name="l02113"></a>02113 <span class="comment"></span><span class="comment">//</span>
<a name="l02114"></a>02114 <span class="comment">//  R : A Computer Language for Statistical Data Analysis</span>
<a name="l02115"></a>02115 <span class="comment">//  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka</span>
<a name="l02116"></a>02116 <span class="comment">//  Copyright (C) 2000 The R Development Core Team</span>
<a name="l02117"></a>02117 <span class="comment">//</span>
<a name="l02118"></a>02118 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l02119"></a>02119 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l02120"></a>02120 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l02121"></a>02121 <span class="comment">//  (at your option) any later version.</span>
<a name="l02122"></a>02122 <span class="comment">//</span>
<a name="l02123"></a>02123 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l02124"></a>02124 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l02125"></a>02125 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l02126"></a>02126 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l02127"></a>02127 <span class="comment">//</span>
<a name="l02128"></a>02128 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l02129"></a>02129 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l02130"></a>02130 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l02131"></a>02131 <span class="comment">//</span>
<a name="l02132"></a>02132 <span class="keywordtype">double</span> 
<a name="l02133"></a><a class="code" href="classlot.html#70e68ac4f715dca7c92eec7ebc62e7b0">02133</a> <a class="code" href="classlot.html#70e68ac4f715dca7c92eec7ebc62e7b0">lot::logis</a>(<span class="keywordtype">double</span> location, <span class="keywordtype">double</span> scale) {
<a name="l02134"></a>02134   <span class="keywordtype">double</span> u = (this-&gt;*uniform_no_zero_generator)();
<a name="l02135"></a>02135   <span class="keywordflow">return</span> location + scale * log(u / (1. - u));
<a name="l02136"></a>02136 }
<a name="l02137"></a>02137 <span class="comment"></span>
<a name="l02138"></a>02138 <span class="comment">/// \f[ f({\bf n}) = {\sum_i n_i \choose n_1 \dots n_I}\prod_i p_i^{n_i} \f]</span>
<a name="l02139"></a>02139 <span class="comment">///</span>
<a name="l02140"></a>02140 <span class="comment">/// \param n                  Sample size (\f$\sum_i n_i\f$)</span>
<a name="l02141"></a>02141 <span class="comment">/// \param p                  Vector of probabilities (\f$p_i\f$)</span>
<a name="l02142"></a>02142 <span class="comment">///</span>
<a name="l02143"></a>02143 <span class="comment">/// Derived from R v2.0. Safety checks eliminated. User must ensure that</span>
<a name="l02144"></a>02144 <span class="comment">/// \f$\sum_i p_i = 1\f$ and \f$p_i &gt;= 0\f$. \f$n &gt; 0\f$ guaranteed, because</span>
<a name="l02145"></a>02145 <span class="comment">/// \f$n\f$ is unsigned.</span>
<a name="l02146"></a>02146 <span class="comment"></span><span class="comment">//</span>
<a name="l02147"></a>02147 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l02148"></a>02148 <span class="comment">//  Copyright (C) 2003        The R Foundation</span>
<a name="l02149"></a>02149 <span class="comment">//</span>
<a name="l02150"></a>02150 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l02151"></a>02151 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l02152"></a>02152 <span class="comment">//  the Free Software Foundation; either version 2, or (at your option)</span>
<a name="l02153"></a>02153 <span class="comment">//  any later version.</span>
<a name="l02154"></a>02154 <span class="comment">//</span>
<a name="l02155"></a>02155 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l02156"></a>02156 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l02157"></a>02157 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l02158"></a>02158 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l02159"></a>02159 <span class="comment">//</span>
<a name="l02160"></a>02160 <span class="comment">//  A copy of the GNU General Public License is available via WWW at</span>
<a name="l02161"></a>02161 <span class="comment">//  http://www.gnu.org/copyleft/gpl.html.  You can also obtain it by</span>
<a name="l02162"></a>02162 <span class="comment">//  writing to the Free Software Foundation, Inc., 59 Temple Place,</span>
<a name="l02163"></a>02163 <span class="comment">//  Suite 330, Boston, MA  02111-1307  USA.</span>
<a name="l02164"></a>02164 <span class="comment">//</span>
<a name="l02165"></a>02165 <span class="comment">//</span>
<a name="l02166"></a>02166 <span class="comment">//  SYNOPSIS</span>
<a name="l02167"></a>02167 <span class="comment">//</span>
<a name="l02168"></a>02168 <span class="comment">//      #include &lt;Rmath.h&gt;</span>
<a name="l02169"></a>02169 <span class="comment">//      void rmultinom(int n, double* prob, int K, int* rN);</span>
<a name="l02170"></a>02170 <span class="comment">//</span>
<a name="l02171"></a>02171 <span class="comment">//  DESCRIPTION</span>
<a name="l02172"></a>02172 <span class="comment">//</span>
<a name="l02173"></a>02173 <span class="comment">//      Random Vector from the multinomial distribution.</span>
<a name="l02174"></a>02174 <span class="comment">//             ~~~~~~</span>
<a name="l02175"></a>02175 <span class="comment">//  NOTE</span>
<a name="l02176"></a>02176 <span class="comment">//      Because we generate random _vectors_ this doesn't fit easily</span>
<a name="l02177"></a>02177 <span class="comment">//      into the do_random[1-4](.) framework setup in ../main/random.c</span>
<a name="l02178"></a>02178 <span class="comment">//      as that is used only for the univariate random generators.</span>
<a name="l02179"></a>02179 <span class="comment">//      Multivariate distributions typically have too complex parameter spaces</span>
<a name="l02180"></a>02180 <span class="comment">//      to be treated uniformly.</span>
<a name="l02181"></a>02181 <span class="comment">//      =&gt; Hence also can have  int arguments.</span>
<a name="l02182"></a>02182 std::vector&lt;int&gt;
<a name="l02183"></a><a class="code" href="classlot.html#704d9846ec0743e03f25f20d060c216a">02183</a> <a class="code" href="classlot.html#704d9846ec0743e03f25f20d060c216a">lot::multinom</a>(<span class="keywordtype">unsigned</span> n, <span class="keyword">const</span> std::vector&lt;double&gt;&amp; p) {
<a name="l02184"></a>02184     <span class="keywordtype">int</span> K = p.size();
<a name="l02185"></a>02185     vector&lt;int&gt; rN(K);
<a name="l02186"></a>02186     <span class="keywordtype">double</span> p_tot = 0.0;
<a name="l02187"></a>02187     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; K; k++) {
<a name="l02188"></a>02188       p_tot += p[k];
<a name="l02189"></a>02189       rN[k] = 0;
<a name="l02190"></a>02190     }
<a name="l02191"></a>02191     <span class="keywordflow">if</span> (n == 0) {
<a name="l02192"></a>02192       <span class="keywordflow">return</span> rN;
<a name="l02193"></a>02193     }
<a name="l02194"></a>02194     <span class="comment">/* Generate the first K-1 obs. via binomials */</span>
<a name="l02195"></a>02195     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; K-1; k++) { <span class="comment">/* (p_tot, n) are for "remaining binomial" */</span>
<a name="l02196"></a>02196       <span class="keywordflow">if</span>(p[k] &gt; 0.0) {
<a name="l02197"></a>02197         <span class="keywordtype">double</span> pp = p[k] / p_tot;
<a name="l02198"></a>02198         rN[k] = ((pp &lt; 1.) ? static_cast&lt;int&gt;(<a class="code" href="classlot.html#dc497ec291a4f5aa0fc327e7e97758be">binom</a>(n,  pp)):
<a name="l02199"></a>02199                  <span class="comment">/*&gt;= 1; &gt; 1 happens because of rounding */</span>
<a name="l02200"></a>02200                  n);
<a name="l02201"></a>02201         n -= rN[k];
<a name="l02202"></a>02202       } <span class="keywordflow">else</span> {
<a name="l02203"></a>02203         rN[k] = 0;
<a name="l02204"></a>02204       }
<a name="l02205"></a>02205       <span class="keywordflow">if</span>(n &lt;= 0) { <span class="comment">/* we have all*/</span> 
<a name="l02206"></a>02206         <span class="keywordflow">return</span> rN;
<a name="l02207"></a>02207       }
<a name="l02208"></a>02208       p_tot -= p[k]; <span class="comment">/* i.e. = sum(p[(k+1):K]) */</span>
<a name="l02209"></a>02209     }
<a name="l02210"></a>02210     rN[K-1] = n;
<a name="l02211"></a>02211     <span class="keywordflow">return</span> rN;
<a name="l02212"></a>02212 }
<a name="l02213"></a>02213 <span class="comment"></span>
<a name="l02214"></a>02214 <span class="comment">/// Returns a negative binomial variate</span>
<a name="l02215"></a>02215 <span class="comment">///</span>
<a name="l02216"></a>02216 <span class="comment">/// \f[ f(x) = \frac{\Gamma(x+n)}{\Gamma(n)x!}p^n(1-p)^x \f]</span>
<a name="l02217"></a>02217 <span class="comment">///</span>
<a name="l02218"></a>02218 <span class="comment">/// \param n         the ``size'' parameter</span>
<a name="l02219"></a>02219 <span class="comment">/// \param p         the ``probability'' parameter</span>
<a name="l02220"></a>02220 <span class="comment">///</span>
<a name="l02221"></a>02221 <span class="comment">/// \f[ \mbox{E}(x) = \frac{x(1-p)}{p} \f]</span>
<a name="l02222"></a>02222 <span class="comment">/// \f[ \mbox{Var}(x) = \frac{x(1-p)}{p^2} \f]</span>
<a name="l02223"></a>02223 <span class="comment">///</span>
<a name="l02224"></a>02224 <span class="comment">/// Derived from R v2.0. Does not check isfinite() on arguments or</span>
<a name="l02225"></a>02225 <span class="comment">/// ensure that p is in [0, 1).</span>
<a name="l02226"></a>02226 <span class="comment"></span><span class="comment">//</span>
<a name="l02227"></a>02227 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l02228"></a>02228 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l02229"></a>02229 <span class="comment">//  Copyright (C) 2000--2001  The R Development Core Team</span>
<a name="l02230"></a>02230 <span class="comment">//</span>
<a name="l02231"></a>02231 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l02232"></a>02232 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l02233"></a>02233 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l02234"></a>02234 <span class="comment">//  (at your option) any later version.</span>
<a name="l02235"></a>02235 <span class="comment">//</span>
<a name="l02236"></a>02236 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l02237"></a>02237 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l02238"></a>02238 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l02239"></a>02239 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l02240"></a>02240 <span class="comment">//</span>
<a name="l02241"></a>02241 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l02242"></a>02242 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l02243"></a>02243 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l02244"></a>02244 <span class="comment">//</span>
<a name="l02245"></a>02245 <span class="comment">//  SYNOPSIS</span>
<a name="l02246"></a>02246 <span class="comment">//</span>
<a name="l02247"></a>02247 <span class="comment">//    #include &lt;Rmath.h&gt;</span>
<a name="l02248"></a>02248 <span class="comment">//    double rnbinom(double n, double p)</span>
<a name="l02249"></a>02249 <span class="comment">//</span>
<a name="l02250"></a>02250 <span class="comment">//  DESCRIPTION</span>
<a name="l02251"></a>02251 <span class="comment">//</span>
<a name="l02252"></a>02252 <span class="comment">//    Random variates from the negative binomial distribution.</span>
<a name="l02253"></a>02253 <span class="comment">//</span>
<a name="l02254"></a>02254 <span class="comment">//  NOTES</span>
<a name="l02255"></a>02255 <span class="comment">//</span>
<a name="l02256"></a>02256 <span class="comment">//    x = the number of failures before the n-th success</span>
<a name="l02257"></a>02257 <span class="comment">//</span>
<a name="l02258"></a>02258 <span class="comment">//  REFERENCE</span>
<a name="l02259"></a>02259 <span class="comment">//</span>
<a name="l02260"></a>02260 <span class="comment">//    Devroye, L. (1986).</span>
<a name="l02261"></a>02261 <span class="comment">//    Non-Uniform Random Variate Generation.</span>
<a name="l02262"></a>02262 <span class="comment">//    New York:Springer-Verlag. Page 480.</span>
<a name="l02263"></a>02263 <span class="comment">//</span>
<a name="l02264"></a>02264 <span class="comment">//  METHOD</span>
<a name="l02265"></a>02265 <span class="comment">//</span>
<a name="l02266"></a>02266 <span class="comment">//    Generate lambda as gamma with shape parameter n and scale</span>
<a name="l02267"></a>02267 <span class="comment">//    parameter p/(1-p).  Return a Poisson deviate with mean lambda.</span>
<a name="l02268"></a>02268 <span class="comment">//</span>
<a name="l02269"></a>02269 <span class="keywordtype">double</span> 
<a name="l02270"></a><a class="code" href="classlot.html#8b34ade0f22a67281bed12e39ea1a604">02270</a> <a class="code" href="classlot.html#8b34ade0f22a67281bed12e39ea1a604">lot::nbinom</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> n <span class="comment">/* size */</span>, <span class="keyword">const</span> <span class="keywordtype">double</span> p <span class="comment">/* prob */</span>) {
<a name="l02271"></a>02271   <span class="keywordflow">return</span> <a class="code" href="classlot.html#c5222f371da3454827e66ea8ae0c0890">poisson</a>(<a class="code" href="classlot.html#7afffff162938dd57de9fe7f18267fd8">gamma</a>(n, (1 - p) / p));
<a name="l02272"></a>02272 }
<a name="l02273"></a>02273 <span class="comment"></span>
<a name="l02274"></a>02274 <span class="comment">/// Returns Poisson deviate</span>
<a name="l02275"></a>02275 <span class="comment">///</span>
<a name="l02276"></a>02276 <span class="comment">/// \f[ f(x) = \frac{\lambda^x e^{-\lambda}}{x!} \f]</span>
<a name="l02277"></a>02277 <span class="comment">///</span>
<a name="l02278"></a>02278 <span class="comment">/// \param mu  mean of the Poisson distribution (\f$\lambda\f$)</span>
<a name="l02279"></a>02279 <span class="comment">///</span>
<a name="l02280"></a>02280 <span class="comment">/// \f[ \mbox{E}(x) = \mu \f]</span>
<a name="l02281"></a>02281 <span class="comment">/// \f[ \mbox{Var}(x) = \mu \f]</span>
<a name="l02282"></a>02282 <span class="comment">///</span>
<a name="l02283"></a>02283 <span class="comment">/// derived from R v1.9.0</span>
<a name="l02284"></a>02284 <span class="comment">///</span>
<a name="l02285"></a>02285 <span class="comment">/// NOTE: Check for finite mu not included</span>
<a name="l02286"></a>02286 <span class="comment">/// </span>
<a name="l02287"></a>02287 <span class="comment">/// NOTE: R uses RNGs uniform on [0,1). To ensure consistency with that</span>
<a name="l02288"></a>02288 <span class="comment">/// well tested code make sure that you have Set_MT(ZERO), or the equivalent,</span>
<a name="l02289"></a>02289 <span class="comment">/// if you are using the Mersenne-Twister. ZERO is the default.</span>
<a name="l02290"></a>02290 <span class="comment">///</span>
<a name="l02291"></a>02291 <span class="comment"></span><span class="comment">// Mathlib : A C Library of Special Functions</span>
<a name="l02292"></a>02292 <span class="comment">//</span>
<a name="l02293"></a>02293 <span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<a name="l02294"></a>02294 <span class="comment">// it under the terms of the GNU General Public License as published by</span>
<a name="l02295"></a>02295 <span class="comment">// the Free Software Foundation; either version 2 of the License, or</span>
<a name="l02296"></a>02296 <span class="comment">// (at your option) any later version.</span>
<a name="l02297"></a>02297 <span class="comment">//</span>
<a name="l02298"></a>02298 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l02299"></a>02299 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l02300"></a>02300 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l02301"></a>02301 <span class="comment">// GNU General Public License for more details.</span>
<a name="l02302"></a>02302 <span class="comment">//</span>
<a name="l02303"></a>02303 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l02304"></a>02304 <span class="comment">// along with this program; if not, write to the Free Software</span>
<a name="l02305"></a>02305 <span class="comment">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l02306"></a>02306 <span class="comment">//</span>
<a name="l02307"></a>02307 <span class="comment">// SYNOPSIS</span>
<a name="l02308"></a>02308 <span class="comment">//</span>
<a name="l02309"></a>02309 <span class="comment">//   #include &lt;Rmath.h&gt;</span>
<a name="l02310"></a>02310 <span class="comment">//   double rpois(double lambda)</span>
<a name="l02311"></a>02311 <span class="comment">//</span>
<a name="l02312"></a>02312 <span class="comment">// DESCRIPTION</span>
<a name="l02313"></a>02313 <span class="comment">//</span>
<a name="l02314"></a>02314 <span class="comment">//   Random variates from the Poisson distribution.</span>
<a name="l02315"></a>02315 <span class="comment">//</span>
<a name="l02316"></a>02316 <span class="comment">// REFERENCE</span>
<a name="l02317"></a>02317 <span class="comment">// </span>
<a name="l02318"></a>02318 <span class="comment">//   Ahrens, J.H. and Dieter, U. (1982).</span>
<a name="l02319"></a>02319 <span class="comment">//   Computer generation of Poisson deviates</span>
<a name="l02320"></a>02320 <span class="comment">//   from modified normal distributions.</span>
<a name="l02321"></a>02321 <span class="comment">//   ACM Trans. Math. Software 8, 163-179.</span>
<a name="l02322"></a>02322 <span class="comment">// </span>
<a name="l02323"></a>02323 <span class="keywordtype">int</span>
<a name="l02324"></a><a class="code" href="classlot.html#c5222f371da3454827e66ea8ae0c0890">02324</a> <a class="code" href="classlot.html#c5222f371da3454827e66ea8ae0c0890">lot::poisson</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> mu) {
<a name="l02325"></a>02325   <span class="comment">/* Factorial Table (0:9)! */</span>
<a name="l02326"></a>02326   <span class="keyword">const</span> <span class="keywordtype">double</span> fact[10] =
<a name="l02327"></a>02327     {
<a name="l02328"></a>02328       1., 1., 2., 6., 24., 120., 720., 5040., 40320., 362880.
<a name="l02329"></a>02329     };
<a name="l02330"></a>02330   <span class="comment">/* These are static --- persistent between calls for same mu : */</span>
<a name="l02331"></a>02331   <span class="keyword">static</span> <span class="keywordtype">int</span> l, m;
<a name="l02332"></a>02332   <span class="keyword">static</span> <span class="keywordtype">double</span> b1, b2, c, c0, c1, c2, c3;
<a name="l02333"></a>02333   <span class="keyword">static</span> <span class="keywordtype">double</span> pp[36], p0, p, q, s, d, omega;
<a name="l02334"></a>02334   <span class="keyword">static</span> <span class="keywordtype">double</span> big_l;<span class="comment">/* integer "w/o overflow" */</span>
<a name="l02335"></a>02335   <span class="keyword">static</span> <span class="keywordtype">double</span> muprev = 0., muprev2 = 0.;<span class="comment">/*, muold      = 0.*/</span>
<a name="l02336"></a>02336 
<a name="l02337"></a>02337   <span class="comment">/* Local Vars  [initialize some for -Wall]: */</span>
<a name="l02338"></a>02338   <span class="keywordtype">double</span> del, difmuk= 0., E= 0., fk= 0., fx, fy, g, px, py, <a class="code" href="classlot.html#2c92917eba7874183e6f3672c9ac2f61">t</a>, u= 0., v, x;
<a name="l02339"></a>02339   <span class="keywordtype">double</span> pois = -1.;
<a name="l02340"></a>02340   <span class="keywordtype">int</span> k, kflag, big_mu, new_big_mu = <span class="keyword">false</span>;
<a name="l02341"></a>02341 
<a name="l02342"></a>02342   <span class="keywordflow">if</span> (mu &lt;= 0.) {
<a name="l02343"></a>02343     <span class="keywordflow">return</span> 0;
<a name="l02344"></a>02344   }
<a name="l02345"></a>02345   big_mu = mu &gt;= 10.;
<a name="l02346"></a>02346   <span class="keywordflow">if</span>(big_mu) {
<a name="l02347"></a>02347     new_big_mu = <span class="keyword">false</span>;
<a name="l02348"></a>02348   }
<a name="l02349"></a>02349   <span class="keywordflow">if</span> (!(big_mu &amp;&amp; mu == muprev)) {<span class="comment">/* maybe compute new persistent par.s */</span>
<a name="l02350"></a>02350     <span class="keywordflow">if</span> (big_mu) {
<a name="l02351"></a>02351             new_big_mu = <span class="keyword">true</span>;
<a name="l02352"></a>02352             <span class="comment">/* Case A. (recalculation of s,d,l  because mu has changed):</span>
<a name="l02353"></a>02353 <span class="comment">             * The poisson probabilities pk exceed the discrete normal</span>
<a name="l02354"></a>02354 <span class="comment">             * probabilities fk whenever k &gt;= m(mu).</span>
<a name="l02355"></a>02355 <span class="comment">             */</span>
<a name="l02356"></a>02356             muprev = mu;
<a name="l02357"></a>02357             s = sqrt(mu);
<a name="l02358"></a>02358             d = 6. * mu * mu;
<a name="l02359"></a>02359             big_l = floor(mu - 1.1484);
<a name="l02360"></a>02360             <span class="comment">/* = an upper bound to m(mu) for all mu &gt;= 10.*/</span>
<a name="l02361"></a>02361     }
<a name="l02362"></a>02362     <span class="keywordflow">else</span> { <span class="comment">/* Small mu ( &lt; 10) -- not using normal approx. */</span>
<a name="l02363"></a>02363             <span class="comment">/* Case B. (start new table and calculate p0 if necessary) */</span>
<a name="l02364"></a>02364             <span class="comment">/*muprev = 0.;-* such that next time, mu != muprev ..*/</span>
<a name="l02365"></a>02365             <span class="keywordflow">if</span> (mu != muprev) {
<a name="l02366"></a>02366         muprev = mu;
<a name="l02367"></a>02367         m = imax2(1, static_cast&lt;int&gt;(mu));
<a name="l02368"></a>02368         l = 0; <span class="comment">/* pp[] is already ok up to pp[l] */</span>
<a name="l02369"></a>02369         q = p0 = p = exp(-mu);
<a name="l02370"></a>02370             }
<a name="l02371"></a>02371             <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l02372"></a>02372         <span class="comment">/* Step U. uniform sample for inversion method */</span>
<a name="l02373"></a>02373         u = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02374"></a>02374         <span class="keywordflow">if</span> (u &lt;= p0) {
<a name="l02375"></a>02375           <span class="keywordflow">return</span> 0;
<a name="l02376"></a>02376         }
<a name="l02377"></a>02377         <span class="comment">/* Step T. table comparison until the end pp[l] of the</span>
<a name="l02378"></a>02378 <span class="comment">           pp-table of cumulative poisson probabilities</span>
<a name="l02379"></a>02379 <span class="comment">           (0.458 &gt; ~= pp[9](= 0.45792971447) for mu=10 ) */</span>
<a name="l02380"></a>02380         <span class="keywordflow">if</span> (l != 0) {
<a name="l02381"></a>02381           <span class="keywordflow">for</span> (k = (u &lt;= 0.458) ? 1 : imin2(l, m);  k &lt;= l; k++)
<a name="l02382"></a>02382             <span class="keywordflow">if</span> (u &lt;= pp[k])
<a name="l02383"></a>02383               <span class="keywordflow">return</span> k;
<a name="l02384"></a>02384           <span class="keywordflow">if</span> (l == 35) <span class="comment">/* u &gt; pp[35] */</span>
<a name="l02385"></a>02385             <span class="keywordflow">continue</span>;
<a name="l02386"></a>02386         }
<a name="l02387"></a>02387         <span class="comment">/* Step C. creation of new poisson</span>
<a name="l02388"></a>02388 <span class="comment">           probabilities p[l..] and their cumulatives q =: pp[k] */</span>
<a name="l02389"></a>02389         l++;
<a name="l02390"></a>02390         <span class="keywordflow">for</span> (k = l; k &lt;= 35; k++) {
<a name="l02391"></a>02391           p *= mu / k;
<a name="l02392"></a>02392           q += p;
<a name="l02393"></a>02393           pp[k] = q;
<a name="l02394"></a>02394           <span class="keywordflow">if</span> (u &lt;= q) {
<a name="l02395"></a>02395             l = k;
<a name="l02396"></a>02396             <span class="keywordflow">return</span> k;
<a name="l02397"></a>02397           }
<a name="l02398"></a>02398         }
<a name="l02399"></a>02399         l = 35;
<a name="l02400"></a>02400             } <span class="comment">/* end(repeat) */</span>
<a name="l02401"></a>02401     }<span class="comment">/* mu &lt; 10 */</span>
<a name="l02402"></a>02402   } <span class="comment">/* end {initialize persistent vars} */</span>
<a name="l02403"></a>02403   <span class="comment">/* Only if mu &gt;= 10 : ----------------------- */</span>
<a name="l02404"></a>02404   <span class="comment">/* Step N. normal sample */</span>
<a name="l02405"></a>02405   g = mu + s * <a class="code" href="lot_8cpp.html#40a3b93beb4e8ce7a943839de82bb661">norm_rand</a>();<span class="comment">/* norm_rand() ~ N(0,1), standard normal */</span>
<a name="l02406"></a>02406   <span class="keywordflow">if</span> (g &gt;= 0.) {
<a name="l02407"></a>02407     pois = floor(g);
<a name="l02408"></a>02408     <span class="comment">/* Step I. immediate acceptance if pois is large enough */</span>
<a name="l02409"></a>02409     <span class="keywordflow">if</span> (pois &gt;= big_l) {
<a name="l02410"></a>02410             <span class="keywordflow">return</span> static_cast&lt;int&gt;(pois);
<a name="l02411"></a>02411     }
<a name="l02412"></a>02412     <span class="comment">/* Step S. squeeze acceptance */</span>
<a name="l02413"></a>02413     fk = pois;
<a name="l02414"></a>02414     difmuk = mu - fk;
<a name="l02415"></a>02415     u = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>(); <span class="comment">/* ~ U(0,1) - sample */</span>
<a name="l02416"></a>02416     <span class="keywordflow">if</span> (d * u &gt;= difmuk * difmuk * difmuk) {
<a name="l02417"></a>02417             <span class="keywordflow">return</span> static_cast&lt;int&gt;(pois);
<a name="l02418"></a>02418     }
<a name="l02419"></a>02419   }
<a name="l02420"></a>02420   <span class="comment">/* Step P. preparations for steps Q and H.</span>
<a name="l02421"></a>02421 <span class="comment">     (recalculations of parameters if necessary) */</span>
<a name="l02422"></a>02422   <span class="keywordflow">if</span> (new_big_mu || mu != muprev2) {
<a name="l02423"></a>02423     <span class="comment">/* Careful! muprev2 is not always == muprev</span>
<a name="l02424"></a>02424 <span class="comment">       because one might have exited in step I or S</span>
<a name="l02425"></a>02425 <span class="comment">    */</span>
<a name="l02426"></a>02426     muprev2 = mu;
<a name="l02427"></a>02427     omega = M_1_SQRT_2PI / s;
<a name="l02428"></a>02428     <span class="comment">/* The quantities b1, b2, c3, c2, c1, c0 are for the Hermite</span>
<a name="l02429"></a>02429 <span class="comment">     * approximations to the discrete normal probabilities fk. */</span>
<a name="l02430"></a>02430     b1 = one_24 / mu;
<a name="l02431"></a>02431     b2 = 0.3 * b1 * b1;
<a name="l02432"></a>02432     c3 = one_7 * b1 * b2;
<a name="l02433"></a>02433     c2 = b2 - 15. * c3;
<a name="l02434"></a>02434     c1 = b1 - 6. * b2 + 45. * c3;
<a name="l02435"></a>02435     c0 = 1. - b1 + 3. * b2 - 15. * c3;
<a name="l02436"></a>02436     c = 0.1069 / mu; <span class="comment">/* guarantees majorization by the 'hat'-function. */</span>
<a name="l02437"></a>02437   }
<a name="l02438"></a>02438   <span class="keywordflow">if</span> (g &gt;= 0.) {
<a name="l02439"></a>02439     <span class="comment">/* 'Subroutine' F is called (kflag=0 for correct return) */</span>
<a name="l02440"></a>02440     kflag = 0;
<a name="l02441"></a>02441     <span class="keywordflow">goto</span> Step_F;
<a name="l02442"></a>02442   }
<a name="l02443"></a>02443   <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l02444"></a>02444     <span class="comment">/* Step E. Exponential Sample */</span>
<a name="l02445"></a>02445     E = <a class="code" href="lot_8cpp.html#1157a8d237f8bb89b614435b4ee1cbef">exp_rand</a>();     <span class="comment">/* ~ Exp(1) (standard exponential) */</span>
<a name="l02446"></a>02446     <span class="comment">/*  sample t from the laplace 'hat'</span>
<a name="l02447"></a>02447 <span class="comment">        (if t &lt;= -0.6744 then pk &lt; fk for all mu &gt;= 10.) */</span>
<a name="l02448"></a>02448     u = 2 * <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>() - 1.;
<a name="l02449"></a>02449     t = 1.8 + fsign(E, u);
<a name="l02450"></a>02450     <span class="keywordflow">if</span> (t &gt; -0.6744) {
<a name="l02451"></a>02451             pois = floor(mu + s * t);
<a name="l02452"></a>02452             fk = pois;
<a name="l02453"></a>02453             difmuk = mu - fk;
<a name="l02454"></a>02454             <span class="comment">/* 'subroutine' F is called (kflag=1 for correct return) */</span>
<a name="l02455"></a>02455             kflag = 1;
<a name="l02456"></a>02456           Step_F: <span class="comment">/* 'subroutine' F : calculation of px,py,fx,fy. */</span>
<a name="l02457"></a>02457             <span class="keywordflow">if</span> (pois &lt; 10) { <span class="comment">/* use factorials from table fact[] */</span>
<a name="l02458"></a>02458         px = -mu;
<a name="l02459"></a>02459         py = pow(mu, pois) / fact[static_cast&lt;int&gt;(pois)];
<a name="l02460"></a>02460             }
<a name="l02461"></a>02461             <span class="keywordflow">else</span> {
<a name="l02462"></a>02462         <span class="comment">/* Case pois &gt;= 10 uses polynomial approximation</span>
<a name="l02463"></a>02463 <span class="comment">           a0-a7 for accuracy when advisable */</span>
<a name="l02464"></a>02464         del = one_12 / fk;
<a name="l02465"></a>02465         del = del * (1. - 4.8 * del * del);
<a name="l02466"></a>02466         v = difmuk / fk;
<a name="l02467"></a>02467         <span class="keywordflow">if</span> (fabs(v) &lt;= 0.25)
<a name="l02468"></a>02468           px = fk * v * v * (((((((a7 * v + a6) * v + a5) * v + a4) *
<a name="l02469"></a>02469                                 v + a3) * v + a2) * v + a1) * v + a0)
<a name="l02470"></a>02470             - del;
<a name="l02471"></a>02471         <span class="keywordflow">else</span> <span class="comment">/* |v| &gt; 1/4 */</span>
<a name="l02472"></a>02472           px = fk * log(1. + v) - difmuk - del;
<a name="l02473"></a>02473         py = M_1_SQRT_2PI / sqrt(fk);
<a name="l02474"></a>02474             }
<a name="l02475"></a>02475             x = (0.5 - difmuk) / s;
<a name="l02476"></a>02476             x *= x;<span class="comment">/* x^2 */</span>
<a name="l02477"></a>02477             fx = -0.5 * x;
<a name="l02478"></a>02478             fy = omega * (((c3 * x + c2) * x + c1) * x + c0);
<a name="l02479"></a>02479             <span class="keywordflow">if</span> (kflag &gt; 0) {
<a name="l02480"></a>02480         <span class="comment">/* Step H. Hat acceptance (E is repeated on rejection) */</span>
<a name="l02481"></a>02481         <span class="keywordflow">if</span> (c * fabs(u) &lt;= py * exp(px + E) - fy * exp(fx + E))
<a name="l02482"></a>02482           <span class="keywordflow">break</span>;
<a name="l02483"></a>02483             } <span class="keywordflow">else</span>
<a name="l02484"></a>02484         <span class="comment">/* Step Q. Quotient acceptance (rare case) */</span>
<a name="l02485"></a>02485         <span class="keywordflow">if</span> (fy - u * fy &lt;= py * exp(px - fx))
<a name="l02486"></a>02486           <span class="keywordflow">break</span>;
<a name="l02487"></a>02487     }<span class="comment">/* t &gt; -.67.. */</span>
<a name="l02488"></a>02488   }
<a name="l02489"></a>02489   <span class="keywordflow">return</span> static_cast&lt;int&gt;(pois);
<a name="l02490"></a>02490 }
<a name="l02491"></a>02491 <span class="comment"></span>
<a name="l02492"></a>02492 <span class="comment">/// Returns standard normal deviate</span>
<a name="l02493"></a>02493 <span class="comment">/// </span>
<a name="l02494"></a>02494 <span class="comment">/// \f[ f(x) = \frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}} \f]</span>
<a name="l02495"></a>02495 <span class="comment">///</span>
<a name="l02496"></a>02496 <span class="comment">/// Kinderman-Ramage standard normal generator from R v1.9.0</span>
<a name="l02497"></a>02497 <span class="comment">///</span>
<a name="l02498"></a>02498 <span class="comment">/// \f[ \mbox{E}(x) = 0 \f]</span>
<a name="l02499"></a>02499 <span class="comment">/// \f[ \mbox{Var}(x) = 1 \f]</span>
<a name="l02500"></a>02500 <span class="comment">///</span>
<a name="l02501"></a>02501 <span class="comment">/// NOTE: R uses RNGs uniform on [0,1). To ensure consistency with that</span>
<a name="l02502"></a>02502 <span class="comment">/// well tested code make sure that you have Set_MT(ZERO), or the equivalent,</span>
<a name="l02503"></a>02503 <span class="comment">/// if you are using the Mersenne-Twister. ZERO is the default.</span>
<a name="l02504"></a>02504 <span class="comment">///</span>
<a name="l02505"></a>02505 <span class="comment"></span><span class="keywordtype">double</span>
<a name="l02506"></a><a class="code" href="classlot.html#161f0527f56c24e5b2c17fda42fc0a6d">02506</a> <a class="code" href="classlot.html#161f0527f56c24e5b2c17fda42fc0a6d">lot::snorm</a>(<span class="keywordtype">void</span>) {
<a name="l02507"></a>02507         <span class="keywordtype">double</span> u1 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02508"></a>02508         <span class="keywordflow">if</span>(u1 &lt; 0.884070402298758) {
<a name="l02509"></a>02509     <span class="keywordtype">double</span> u2 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02510"></a>02510     <span class="keywordflow">return</span> A*(1.131131635444180*u1+u2-1);
<a name="l02511"></a>02511         }
<a name="l02512"></a>02512         <span class="keywordflow">if</span>(u1 &gt;= 0.973310954173898) { <span class="comment">/* tail: */</span>
<a name="l02513"></a>02513     <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l02514"></a>02514       <span class="keywordtype">double</span> u2 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02515"></a>02515       <span class="keywordtype">double</span> u3 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02516"></a>02516       <span class="keywordtype">double</span> tt = (A*A-2*log(u3));
<a name="l02517"></a>02517       <span class="keywordflow">if</span>( u2*u2&lt;(A*A)/tt )
<a name="l02518"></a>02518                     <span class="keywordflow">return</span> (u1 &lt; 0.986655477086949) ? sqrt(tt) : -sqrt(tt);
<a name="l02519"></a>02519     }
<a name="l02520"></a>02520         }
<a name="l02521"></a>02521         <span class="keywordflow">if</span>(u1 &gt;= 0.958720824790463) { <span class="comment">/* region3: */</span>
<a name="l02522"></a>02522     <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l02523"></a>02523       <span class="keywordtype">double</span> u2 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02524"></a>02524       <span class="keywordtype">double</span> u3 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02525"></a>02525       <span class="keywordtype">double</span> tt = A - 0.630834801921960* fmin2(u2,u3);
<a name="l02526"></a>02526       <span class="keywordflow">if</span>(fmax2(u2,u3) &lt;= 0.755591531667601)
<a name="l02527"></a>02527                     <span class="keywordflow">return</span> (u2&lt;u3) ? tt : -tt;
<a name="l02528"></a>02528       <span class="keywordflow">if</span>(0.034240503750111*fabs(u2-u3) &lt;= g(tt))
<a name="l02529"></a>02529                     <span class="keywordflow">return</span> (u2&lt;u3) ? tt : -tt;
<a name="l02530"></a>02530     }
<a name="l02531"></a>02531         }
<a name="l02532"></a>02532         <span class="keywordflow">if</span>(u1 &gt;= 0.911312780288703) { <span class="comment">/* region2: */</span>
<a name="l02533"></a>02533     <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l02534"></a>02534       <span class="keywordtype">double</span> u2 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02535"></a>02535       <span class="keywordtype">double</span> u3 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02536"></a>02536       <span class="keywordtype">double</span> tt = 0.479727404222441+1.105473661022070*fmin2(u2,u3);
<a name="l02537"></a>02537       <span class="keywordflow">if</span>( fmax2(u2,u3)&lt;=0.872834976671790 )
<a name="l02538"></a>02538                     <span class="keywordflow">return</span> (u2&lt;u3) ? tt : -tt;
<a name="l02539"></a>02539       <span class="keywordflow">if</span>( 0.049264496373128*fabs(u2-u3)&lt;=g(tt) )
<a name="l02540"></a>02540                     <span class="keywordflow">return</span> (u2&lt;u3) ? tt : -tt;
<a name="l02541"></a>02541     }
<a name="l02542"></a>02542         }
<a name="l02543"></a>02543         <span class="comment">/* ELSE  region1: */</span>
<a name="l02544"></a>02544         <a class="code" href="lot_8cpp.html#88f47a79aa968bbb4c64a245c2c14437">repeat</a> {
<a name="l02545"></a>02545     <span class="keywordtype">double</span> u2 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02546"></a>02546     <span class="keywordtype">double</span> u3 = <a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>();
<a name="l02547"></a>02547     <span class="keywordtype">double</span> tt = 0.479727404222441-0.595507138015940*fmin2(u2,u3);
<a name="l02548"></a>02548     <span class="keywordflow">if</span> (tt &lt; 0.) <span class="keywordflow">continue</span>;
<a name="l02549"></a>02549     <span class="keywordflow">if</span>(fmax2(u2,u3) &lt;= 0.805577924423817)
<a name="l02550"></a>02550       <span class="keywordflow">return</span> (u2&lt;u3) ? tt : -tt;
<a name="l02551"></a>02551     <span class="keywordflow">if</span>(0.053377549506886*fabs(u2-u3) &lt;= g(tt))
<a name="l02552"></a>02552       <span class="keywordflow">return</span> (u2&lt;u3) ? tt : -tt;
<a name="l02553"></a>02553         }
<a name="l02554"></a>02554 }
<a name="l02555"></a>02555 <span class="comment"></span>
<a name="l02556"></a>02556 <span class="comment">/// Returns a t variate</span>
<a name="l02557"></a>02557 <span class="comment">///</span>
<a name="l02558"></a>02558 <span class="comment">/// \f[ f(x) = \frac{\Gamma(\frac{\nu+1}{2})}{\sqrt{\pi\nu}\Gamma(\frac{\nu}{2})(1 + \frac{x^2}{\nu})^{(\nu + 1)/2}} \f]</span>
<a name="l02559"></a>02559 <span class="comment">///</span>
<a name="l02560"></a>02560 <span class="comment">/// \param df        the degrees of freedom (\f$\nu\f$)</span>
<a name="l02561"></a>02561 <span class="comment">///</span>
<a name="l02562"></a>02562 <span class="comment">/// \f[ \mbox{E}(x) = 0 \quad , \quad \nu &gt; 1 \f]</span>
<a name="l02563"></a>02563 <span class="comment">/// \f[ \mbox{Var}(x) = \frac{\nu}{\nu - 2} \quad , \quad \nu &gt; 2 \f]</span>
<a name="l02564"></a>02564 <span class="comment">///</span>
<a name="l02565"></a>02565 <span class="comment">/// Derived from R v2.0. Does not check isnan() or isfinite() on argument.</span>
<a name="l02566"></a>02566 <span class="comment"></span><span class="comment">//</span>
<a name="l02567"></a>02567 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l02568"></a>02568 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l02569"></a>02569 <span class="comment">//  Copyright (C) 2000-2001 The R Development Core Team</span>
<a name="l02570"></a>02570 <span class="comment">//</span>
<a name="l02571"></a>02571 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l02572"></a>02572 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l02573"></a>02573 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l02574"></a>02574 <span class="comment">//  (at your option) any later version.</span>
<a name="l02575"></a>02575 <span class="comment">//</span>
<a name="l02576"></a>02576 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l02577"></a>02577 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l02578"></a>02578 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l02579"></a>02579 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l02580"></a>02580 <span class="comment">//</span>
<a name="l02581"></a>02581 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l02582"></a>02582 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l02583"></a>02583 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l02584"></a>02584 <span class="comment">//</span>
<a name="l02585"></a>02585 <span class="comment">//  DESCRIPTION</span>
<a name="l02586"></a>02586 <span class="comment">//</span>
<a name="l02587"></a>02587 <span class="comment">//    Pseudo-random variates from a t distribution.</span>
<a name="l02588"></a>02588 <span class="comment">//</span>
<a name="l02589"></a>02589 <span class="comment">//  NOTES</span>
<a name="l02590"></a>02590 <span class="comment">//</span>
<a name="l02591"></a>02591 <span class="comment">//    This function calls rchisq and rnorm to do the real work.</span>
<a name="l02592"></a>02592 <span class="comment">//</span>
<a name="l02593"></a>02593 <span class="keywordtype">double</span> 
<a name="l02594"></a><a class="code" href="classlot.html#2c92917eba7874183e6f3672c9ac2f61">02594</a> <a class="code" href="classlot.html#2c92917eba7874183e6f3672c9ac2f61">lot::t</a>(<span class="keywordtype">double</span> <a class="code" href="namespaceDensity.html#d2fdc3054803956e0b26d84fd16ff4e3">df</a>) {
<a name="l02595"></a>02595   <span class="keywordtype">double</span> num;
<a name="l02596"></a>02596   <span class="comment">/* Some compilers (including MW6) evaluated this from right to left</span>
<a name="l02597"></a>02597 <span class="comment">     return norm_rand() / sqrt(rchisq(df) / df); */</span>
<a name="l02598"></a>02598         num = <a class="code" href="lot_8cpp.html#40a3b93beb4e8ce7a943839de82bb661">norm_rand</a>();
<a name="l02599"></a>02599         <span class="keywordflow">return</span> num / sqrt(<a class="code" href="classlot.html#4d9467088ac8bbbae410107575405306">chisq</a>(df) / df);
<a name="l02600"></a>02600 }
<a name="l02601"></a>02601 <span class="comment"></span>
<a name="l02602"></a>02602 <span class="comment">/// Returns a Weibull variate</span>
<a name="l02603"></a>02603 <span class="comment">///</span>
<a name="l02604"></a>02604 <span class="comment">/// \f[ f(x) = (\frac{a}{b})(\frac{x}{b})^{a-1}e^{-\frac{x}{b}^a} \f]</span>
<a name="l02605"></a>02605 <span class="comment">///</span>
<a name="l02606"></a>02606 <span class="comment">/// \param shape        the ``shape'' parameter (\f$a\f$)</span>
<a name="l02607"></a>02607 <span class="comment">/// \param scale        the ``scale'' parameter (\f$b\f$)</span>
<a name="l02608"></a>02608 <span class="comment">///</span>
<a name="l02609"></a>02609 <span class="comment">/// \f[ \mbox{E}(x) = b\Gamma(1 + \frac{1}{a}) \f]</span>
<a name="l02610"></a>02610 <span class="comment">/// \f[ \mbox{Var}(x) = b^2(\Gamma(1+\frac{2}{a}) - \Gamma(1+\frac{1}{a})^2) \f]</span>
<a name="l02611"></a>02611 <span class="comment">///</span>
<a name="l02612"></a>02612 <span class="comment">/// Derived from R v2.0. Does not check isnan() on arguments. Does not</span>
<a name="l02613"></a>02613 <span class="comment">/// check for \f$a &gt; 0\f$ and \f$b &gt; 0\f$.</span>
<a name="l02614"></a>02614 <span class="comment"></span><span class="comment">//</span>
<a name="l02615"></a>02615 <span class="comment">//  Mathlib : A C Library of Special Functions</span>
<a name="l02616"></a>02616 <span class="comment">//  Copyright (C) 1998 Ross Ihaka</span>
<a name="l02617"></a>02617 <span class="comment">//  Copyright (C) 2000 The R Development Core Team</span>
<a name="l02618"></a>02618 <span class="comment">//</span>
<a name="l02619"></a>02619 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
<a name="l02620"></a>02620 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l02621"></a>02621 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l02622"></a>02622 <span class="comment">//  (at your option) any later version.</span>
<a name="l02623"></a>02623 <span class="comment">//</span>
<a name="l02624"></a>02624 <span class="comment">//  This program is distributed in the hope that it will be useful,</span>
<a name="l02625"></a>02625 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l02626"></a>02626 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l02627"></a>02627 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l02628"></a>02628 <span class="comment">//</span>
<a name="l02629"></a>02629 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l02630"></a>02630 <span class="comment">//  along with this program; if not, write to the Free Software</span>
<a name="l02631"></a>02631 <span class="comment">//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.</span>
<a name="l02632"></a>02632 <span class="comment">//</span>
<a name="l02633"></a>02633 <span class="comment">//  DESCRIPTION</span>
<a name="l02634"></a>02634 <span class="comment">//</span>
<a name="l02635"></a>02635 <span class="comment">//    Random variates from the Weibull distribution.</span>
<a name="l02636"></a>02636 <span class="comment">//</span>
<a name="l02637"></a>02637 <span class="keywordtype">double</span> 
<a name="l02638"></a><a class="code" href="classlot.html#2e85b52df4b5b7c26f8c4cc94c6c45d9">02638</a> <a class="code" href="classlot.html#2e85b52df4b5b7c26f8c4cc94c6c45d9">lot::weibull</a>(<span class="keywordtype">double</span> shape, <span class="keywordtype">double</span> scale) {
<a name="l02639"></a>02639   <span class="keywordflow">return</span> scale * pow(-log(<a class="code" href="lot_8cpp.html#3455dfa8cd86ca3ebcf8c6d14f1da664">unif_rand</a>()), 1.0 / shape);
<a name="l02640"></a>02640 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Mar 27 16:03:38 2007 for mcmc by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
